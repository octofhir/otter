//! # Den - Declarative Extension Module Registration
//!
//! This module provides the `den!` macro for declaratively registering
//! extension modules with their native functions (dives) and JavaScript code.
//!
//! ## Otter Terminology
//!
//! A **den** is an otter's home - a cozy burrow where it stores its treasures.
//! In Otter runtime, a den is an extension module that bundles:
//! - Native functions (dives) that go deep into Rust code
//! - JavaScript wrapper code that exposes these functions to JS
//!
//! ## Example
//!
//! ```ignore
//! use otter_macros::dive;
//! use otter_runtime::den;
//!
//! #[dive(swift)]
//! fn join(parts: Vec<String>) -> String {
//!     parts.join("/")
//! }
//!
//! #[dive(swift)]
//! fn dirname(path: String) -> String {
//!     // ... implementation
//! }
//!
//! den!(path {
//!     dives: [join, dirname],
//!     js: "path.js",
//! });
//!
//! // This generates:
//! // pub fn path_extension() -> Extension { ... }
//! ```
//!
//! ## With Dependencies
//!
//! ```ignore
//! den!(net {
//!     needs: [events],  // depends on events module
//!     dives: [listen, accept, connect],
//!     js: "net.js",
//! });
//! ```

/// Define an extension module - an otter's den with native treasures and JS magic.
///
/// # Syntax
///
/// ```ignore
/// den!(module_name {
///     needs: [dep1, dep2],           // Optional: dependencies
///     dives: [func1, func2, func3],  // Required: dive functions
///     js: "module.js",               // Required: JS wrapper file path
/// });
/// ```
///
/// # Generated Code
///
/// The macro generates a function `{module_name}_extension()` that returns
/// an `Extension` configured with:
/// - The dive functions as ops
/// - The JavaScript code from the specified file
///
/// # Example
///
/// ```ignore
/// use otter_macros::dive;
/// use otter_runtime::den;
///
/// #[dive(swift)]
/// fn add(a: i32, b: i32) -> i32 { a + b }
///
/// #[dive(swift)]
/// fn multiply(a: i32, b: i32) -> i32 { a * b }
///
/// den!(math {
///     dives: [add, multiply],
///     js: "math.js",
/// });
///
/// // Now you can use:
/// // let ext = math_extension();
/// ```
#[macro_export]
macro_rules! den {
    // With dependencies
    (
        $name:ident {
            needs: [ $($dep:ident),* $(,)? ],
            dives: [ $($dive:ident),* $(,)? ],
            js: $js_path:literal $(,)?
        }
    ) => {
        /// Creates the extension for this den.
        /// Auto-generated by den! macro.
        pub fn $crate::paste::paste! { [<$name _extension>] }() -> $crate::Extension {
            $crate::Extension::new(stringify!($name))
                .with_ops(vec![
                    $( $crate::paste::paste! { [<$dive _dive_decl>] }() ),*
                ])
                .with_js(include_str!($js_path))
        }
    };

    // Without dependencies (simpler form)
    (
        $name:ident {
            dives: [ $($dive:ident),* $(,)? ],
            js: $js_path:literal $(,)?
        }
    ) => {
        $crate::paste::paste! {
            /// Creates the extension for this den.
            /// Auto-generated by den! macro.
            pub fn [<$name _extension>]() -> $crate::Extension {
                $crate::Extension::new(stringify!($name))
                    .with_ops(vec![
                        $( [<$dive _dive_decl>]() ),*
                    ])
                    .with_js(include_str!($js_path))
            }
        }
    };

    // Inline JS (for simple cases without separate file)
    (
        $name:ident {
            dives: [ $($dive:ident),* $(,)? ],
            js_inline: $js_code:literal $(,)?
        }
    ) => {
        $crate::paste::paste! {
            /// Creates the extension for this den.
            /// Auto-generated by den! macro.
            pub fn [<$name _extension>]() -> $crate::Extension {
                $crate::Extension::new(stringify!($name))
                    .with_ops(vec![
                        $( [<$dive _dive_decl>]() ),*
                    ])
                    .with_js($js_code)
            }
        }
    };
}

// Re-export paste for use in the macro
pub use paste::paste;

#[cfg(test)]
mod tests {
    // den! macro tests would go here
    // They need to be in an integration test since they use the dive macro
}
