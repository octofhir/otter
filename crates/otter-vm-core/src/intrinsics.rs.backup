//! Intrinsics registry for ECMAScript built-in objects and well-known symbols.
//!
//! This module provides the `Intrinsics` struct which holds references to all
//! intrinsic objects (constructors, prototypes) and well-known symbols.
//! It is created once per `VmRuntime` and shared across contexts.
//!
//! The initialization follows a two-stage pattern (inspired by Boa):
//! 1. **Stage 1**: Allocate empty prototype/constructor objects to break circular deps
//! 2. **Stage 2**: Initialize properties in dependency order using `BuiltInBuilder`

use std::sync::Arc;


use crate::gc::GcRef;
use crate::memory::MemoryManager;
use crate::object::JsObject;
use crate::intrinsics_impl::helpers::{same_value_zero, strict_equal};

use crate::value::{Symbol, Value};



/// Well-known symbol IDs (fixed, pre-defined).
/// These must match the IDs in `otter-vm-builtins/src/symbol.rs`.
pub mod well_known {
    /// `Symbol.iterator`
    pub const ITERATOR: u64 = 1;
    /// `Symbol.asyncIterator`
    pub const ASYNC_ITERATOR: u64 = 2;
    /// `Symbol.toStringTag`
    pub const TO_STRING_TAG: u64 = 3;
    /// `Symbol.hasInstance`
    pub const HAS_INSTANCE: u64 = 4;
    /// `Symbol.toPrimitive`
    pub const TO_PRIMITIVE: u64 = 5;
    /// `Symbol.isConcatSpreadable`
    pub const IS_CONCAT_SPREADABLE: u64 = 6;
    /// `Symbol.match`
    pub const MATCH: u64 = 7;
    /// `Symbol.matchAll`
    pub const MATCH_ALL: u64 = 8;
    /// `Symbol.replace`
    pub const REPLACE: u64 = 9;
    /// `Symbol.search`
    pub const SEARCH: u64 = 10;
    /// `Symbol.split`
    pub const SPLIT: u64 = 11;
    /// `Symbol.species`
    pub const SPECIES: u64 = 12;
    /// `Symbol.unscopables`
    pub const UNSCOPABLES: u64 = 13;
}

/// Registry of all ECMAScript intrinsic objects and well-known symbols.
///
/// Created once per `VmRuntime`, shared across all contexts.
/// Provides direct Rust access to intrinsics without JS global lookups.
#[derive(Clone)]
pub struct Intrinsics {
    // ========================================================================
    // Core prototypes
    // ========================================================================
    /// `Object.prototype` — `[[Prototype]]` is `null`
    pub object_prototype: GcRef<JsObject>,
    /// `Function.prototype` — `[[Prototype]]` is `Object.prototype`
    pub function_prototype: GcRef<JsObject>,

    // ========================================================================
    // Core constructors
    // ========================================================================
    /// `Object` constructor
    pub object_constructor: GcRef<JsObject>,
    /// `Function` constructor
    pub function_constructor: GcRef<JsObject>,

    // ========================================================================
    // Primitive wrapper prototypes
    // ========================================================================
    /// `String.prototype`
    pub string_prototype: GcRef<JsObject>,
    /// `Number.prototype`
    pub number_prototype: GcRef<JsObject>,
    /// `Boolean.prototype`
    pub boolean_prototype: GcRef<JsObject>,
    /// `Symbol.prototype`
    pub symbol_prototype: GcRef<JsObject>,
    /// `BigInt.prototype`
    pub bigint_prototype: GcRef<JsObject>,

    // ========================================================================
    // Collection prototypes
    // ========================================================================
    /// `Array.prototype`
    pub array_prototype: GcRef<JsObject>,
    /// `Map.prototype`
    pub map_prototype: GcRef<JsObject>,
    /// `Set.prototype`
    pub set_prototype: GcRef<JsObject>,
    /// `WeakMap.prototype`
    pub weak_map_prototype: GcRef<JsObject>,
    /// `WeakSet.prototype`
    pub weak_set_prototype: GcRef<JsObject>,

    // ========================================================================
    // Error prototypes
    // ========================================================================
    /// `Error.prototype`
    pub error_prototype: GcRef<JsObject>,
    /// `TypeError.prototype`
    pub type_error_prototype: GcRef<JsObject>,
    /// `RangeError.prototype`
    pub range_error_prototype: GcRef<JsObject>,
    /// `ReferenceError.prototype`
    pub reference_error_prototype: GcRef<JsObject>,
    /// `SyntaxError.prototype`
    pub syntax_error_prototype: GcRef<JsObject>,
    /// `URIError.prototype`
    pub uri_error_prototype: GcRef<JsObject>,
    /// `EvalError.prototype`
    pub eval_error_prototype: GcRef<JsObject>,

    // ========================================================================
    // Async/Promise
    // ========================================================================
    /// `Promise.prototype`
    pub promise_prototype: GcRef<JsObject>,

    // ========================================================================
    // Other built-in prototypes
    // ========================================================================
    /// `RegExp.prototype`
    pub regexp_prototype: GcRef<JsObject>,
    /// `Date.prototype`
    pub date_prototype: GcRef<JsObject>,
    /// `ArrayBuffer.prototype`
    pub array_buffer_prototype: GcRef<JsObject>,
    /// `DataView.prototype`
    pub data_view_prototype: GcRef<JsObject>,

    // ========================================================================
    // Iterator prototypes
    // ========================================================================
    /// `%IteratorPrototype%` — base for all iterator prototypes
    pub iterator_prototype: GcRef<JsObject>,
    /// `%AsyncIteratorPrototype%`
    pub async_iterator_prototype: GcRef<JsObject>,

    // ========================================================================
    // Well-known symbols (Value::symbol)
    // ========================================================================
    /// `Symbol.iterator`
    pub symbol_iterator: Value,
    /// `Symbol.asyncIterator`
    pub symbol_async_iterator: Value,
    /// `Symbol.toStringTag`
    pub symbol_to_string_tag: Value,
    /// `Symbol.hasInstance`
    pub symbol_has_instance: Value,
    /// `Symbol.toPrimitive`
    pub symbol_to_primitive: Value,
    /// `Symbol.isConcatSpreadable`
    pub symbol_is_concat_spreadable: Value,
    /// `Symbol.match`
    pub symbol_match: Value,
    /// `Symbol.matchAll`
    pub symbol_match_all: Value,
    /// `Symbol.replace`
    pub symbol_replace: Value,
    /// `Symbol.search`
    pub symbol_search: Value,
    /// `Symbol.split`
    pub symbol_split: Value,
    /// `Symbol.species`
    pub symbol_species: Value,
    /// `Symbol.unscopables`
    pub symbol_unscopables: Value,
}

impl Intrinsics {
    /// Create a new `Intrinsics` with all objects allocated but NOT yet initialized.
    ///
    /// This is Stage 1 of the two-stage initialization. Call `init()` after
    /// this to populate properties and wire prototype chains (Stage 2).
    ///
    /// `fn_proto` is the pre-existing intrinsic `%Function.prototype%` created
    /// by `VmRuntime` before this call.
    pub fn allocate(mm: &Arc<MemoryManager>, fn_proto: GcRef<JsObject>) -> Self {
        // Helper to allocate an empty object with no prototype
        let alloc = || GcRef::new(JsObject::new(None, mm.clone()));

        // Create well-known symbols
        let make_symbol = |id: u64, desc: &str| -> Value {
            Value::symbol(Arc::new(Symbol {
                description: Some(desc.to_string()),
                id,
            }))
        };

        Self {
            // Core prototypes
            object_prototype: alloc(),
            function_prototype: fn_proto, // Reuse existing intrinsic
            // Core constructors
            object_constructor: alloc(),
            function_constructor: alloc(),
            // Primitive wrappers
            string_prototype: alloc(),
            number_prototype: alloc(),
            boolean_prototype: alloc(),
            symbol_prototype: alloc(),
            bigint_prototype: alloc(),
            // Collections
            array_prototype: alloc(),
            map_prototype: alloc(),
            set_prototype: alloc(),
            weak_map_prototype: alloc(),
            weak_set_prototype: alloc(),
            // Errors
            error_prototype: alloc(),
            type_error_prototype: alloc(),
            range_error_prototype: alloc(),
            reference_error_prototype: alloc(),
            syntax_error_prototype: alloc(),
            uri_error_prototype: alloc(),
            eval_error_prototype: alloc(),
            // Promise
            promise_prototype: alloc(),
            // Other
            regexp_prototype: alloc(),
            date_prototype: alloc(),
            array_buffer_prototype: alloc(),
            data_view_prototype: alloc(),
            // Iterators
            iterator_prototype: alloc(),
            async_iterator_prototype: alloc(),
            // Well-known symbols
            symbol_iterator: make_symbol(well_known::ITERATOR, "Symbol.iterator"),
            symbol_async_iterator: make_symbol(well_known::ASYNC_ITERATOR, "Symbol.asyncIterator"),
            symbol_to_string_tag: make_symbol(well_known::TO_STRING_TAG, "Symbol.toStringTag"),
            symbol_has_instance: make_symbol(well_known::HAS_INSTANCE, "Symbol.hasInstance"),
            symbol_to_primitive: make_symbol(well_known::TO_PRIMITIVE, "Symbol.toPrimitive"),
            symbol_is_concat_spreadable: make_symbol(
                well_known::IS_CONCAT_SPREADABLE,
                "Symbol.isConcatSpreadable",
            ),
            symbol_match: make_symbol(well_known::MATCH, "Symbol.match"),
            symbol_match_all: make_symbol(well_known::MATCH_ALL, "Symbol.matchAll"),
            symbol_replace: make_symbol(well_known::REPLACE, "Symbol.replace"),
            symbol_search: make_symbol(well_known::SEARCH, "Symbol.search"),
            symbol_split: make_symbol(well_known::SPLIT, "Symbol.split"),
            symbol_species: make_symbol(well_known::SPECIES, "Symbol.species"),
            symbol_unscopables: make_symbol(well_known::UNSCOPABLES, "Symbol.unscopables"),
        }
    }

    /// Stage 2: Wire up prototype chains for all intrinsic objects.
    ///
    /// This sets the `[[Prototype]]` of each intrinsic object according to
    /// the ECMAScript specification. Must be called after `allocate()`.
    pub fn wire_prototype_chains(&self) {
        // Object.prototype.[[Prototype]] = null (already null from allocate)

        // Function.prototype.[[Prototype]] = Object.prototype
        self.function_prototype
            .set_prototype(Some(self.object_prototype));

        // All other prototypes chain to Object.prototype
        let protos_to_obj = [
            self.string_prototype,
            self.number_prototype,
            self.boolean_prototype,
            self.symbol_prototype,
            self.bigint_prototype,
            self.array_prototype,
            self.map_prototype,
            self.set_prototype,
            self.weak_map_prototype,
            self.weak_set_prototype,
            self.promise_prototype,
            self.regexp_prototype,
            self.date_prototype,
            self.array_buffer_prototype,
            self.data_view_prototype,
            self.iterator_prototype,
        ];
        for proto in &protos_to_obj {
            proto.set_prototype(Some(self.object_prototype));
        }

        // Error.prototype.[[Prototype]] = Object.prototype
        self.error_prototype
            .set_prototype(Some(self.object_prototype));

        // All specific error prototypes chain to Error.prototype
        let error_protos = [
            self.type_error_prototype,
            self.range_error_prototype,
            self.reference_error_prototype,
            self.syntax_error_prototype,
            self.uri_error_prototype,
            self.eval_error_prototype,
        ];
        for proto in &error_protos {
            proto.set_prototype(Some(self.error_prototype));
        }

        // AsyncIteratorPrototype.[[Prototype]] = Object.prototype
        self.async_iterator_prototype
            .set_prototype(Some(self.object_prototype));

        // Constructor objects: [[Prototype]] = Function.prototype
        let ctors = [self.object_constructor, self.function_constructor];
        for ctor in &ctors {
            ctor.set_prototype(Some(self.function_prototype));
        }
    }

    /// Stage 3: Initialize core intrinsic properties using `BuiltInBuilder`.
    ///
    /// This populates Object.prototype, Function.prototype, and Error prototypes
    /// with their spec-required methods and properties. Must be called after
    /// `wire_prototype_chains()`.
    pub fn init_core(&self, mm: &Arc<MemoryManager>) {
        use crate::builtin_builder::BuiltInBuilder;
        use crate::object::{PropertyAttributes, PropertyDescriptor, PropertyKey};
        use crate::string::JsString;

        // ====================================================================
        // Object.prototype methods (non-enumerable)
        // ====================================================================
        let obj_proto = self.object_prototype;
        let fn_proto = self.function_prototype;

        // Object.prototype.toString
        obj_proto.define_property(
            PropertyKey::string("toString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, _args, _mm| Ok(Value::string(JsString::intern("[object Object]"))),
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.prototype.valueOf
        obj_proto.define_property(
            PropertyKey::string("valueOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| Ok(this_val.clone()),
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.prototype.hasOwnProperty
        obj_proto.define_property(
            PropertyKey::string("hasOwnProperty"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    if let Some(obj) = this_val.as_object() {
                        if let Some(key) = args.first() {
                            if let Some(s) = key.as_string() {
                                return Ok(Value::boolean(
                                    obj.has(&PropertyKey::string(s.as_str())),
                                ));
                            }
                        }
                    }
                    Ok(Value::boolean(false))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.prototype.isPrototypeOf
        obj_proto.define_property(
            PropertyKey::string("isPrototypeOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    if let Some(target) = args.first().and_then(|v| v.as_object()) {
                        if let Some(this_obj) = this_val.as_object() {
                            let mut current = target.prototype();
                            while let Some(proto) = current {
                                if std::ptr::eq(
                                    proto.as_ptr() as *const _,
                                    this_obj.as_ptr() as *const _,
                                ) {
                                    return Ok(Value::boolean(true));
                                }
                                current = proto.prototype();
                            }
                        }
                    }
                    Ok(Value::boolean(false))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.prototype.propertyIsEnumerable
        obj_proto.define_property(
            PropertyKey::string("propertyIsEnumerable"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    if let Some(obj) = this_val.as_object() {
                        if let Some(key) = args.first() {
                            if let Some(s) = key.as_string() {
                                let pk = PropertyKey::string(s.as_str());
                                if let Some(desc) = obj.get_own_property_descriptor(&pk) {
                                    return Ok(Value::boolean(desc.enumerable()));
                                }
                            }
                        }
                    }
                    Ok(Value::boolean(false))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // ====================================================================
        // Function.prototype methods (non-enumerable)
        // ====================================================================

        // Function.prototype.toString
        fn_proto.define_property(
            PropertyKey::string("toString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    if this_val.is_function() {
                        if let Some(closure) = this_val.as_function() {
                            return Ok(Value::string(JsString::intern(&format!(
                                "function {}() {{ [native code] }}",
                                if closure.is_async { "async " } else { "" }
                            ))));
                        }
                    }
                    if this_val.is_native_function() {
                        return Ok(Value::string(JsString::intern(
                            "function () { [native code] }",
                        )));
                    }
                    if let Some(obj) = this_val.as_object() {
                        if obj.get(&PropertyKey::string("__boundFunction__")).is_some() {
                            return Ok(Value::string(JsString::intern(
                                "function () { [bound] }",
                            )));
                        }
                    }
                    Ok(Value::string(JsString::intern(
                        "function () { [native code] }",
                    )))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Function.prototype.call - stub, actual dispatch handled by interpreter
        fn_proto.define_property(
            PropertyKey::string("call"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, _args, _mm| {
                    Err("Function.prototype.call: interpreter interception failed".to_string())
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Function.prototype.apply - stub, actual dispatch handled by interpreter
        fn_proto.define_property(
            PropertyKey::string("apply"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, _args, _mm| {
                    Err("Function.prototype.apply: interpreter interception failed".to_string())
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Function.prototype.bind
        fn_proto.define_property(
            PropertyKey::string("bind"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, mm_inner| {
                    // this_val is the function being bound
                    let this_arg = args.first().cloned().unwrap_or(Value::undefined());

                    let bound = GcRef::new(JsObject::new(None, mm_inner.clone()));

                    // Store the original function
                    bound.set(
                        PropertyKey::string("__boundFunction__"),
                        this_val.clone(),
                    );
                    // Store the thisArg
                    bound.set(PropertyKey::string("__boundThis__"), this_arg);

                    // Store bound arguments (if any)
                    if args.len() > 1 {
                        let arr = GcRef::new(JsObject::new(None, mm_inner));
                        for (i, arg) in args[1..].iter().enumerate() {
                            arr.set(PropertyKey::Index(i as u32), arg.clone());
                        }
                        arr.set(
                            PropertyKey::string("length"),
                            Value::int32((args.len() - 1) as i32),
                        );
                        bound.set(
                            PropertyKey::string("__boundArgs__"),
                            Value::object(arr),
                        );
                    }

                    // Set name
                    bound.set(
                        PropertyKey::string("__boundName__"),
                        Value::string(JsString::intern("bound ")),
                    );

                    // Set length (original length - bound args count, min 0)
                    let bound_args_len =
                        if args.len() > 1 { args.len() - 1 } else { 0 };
                    let new_length =
                        0i32.saturating_sub(bound_args_len as i32).max(0);
                    bound.set(
                        PropertyKey::string("__boundLength__"),
                        Value::int32(new_length),
                    );

                    // Mark as callable
                    bound.set(
                        PropertyKey::string("__isCallable__"),
                        Value::boolean(true),
                    );

                    Ok(Value::object(bound))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // ====================================================================
        // Error.prototype properties
        // ====================================================================
        self.error_prototype.define_property(
            PropertyKey::string("name"),
            PropertyDescriptor::data_with_attrs(
                Value::string(JsString::intern("Error")),
                PropertyAttributes::builtin_method(),
            ),
        );
        self.error_prototype.define_property(
            PropertyKey::string("message"),
            PropertyDescriptor::data_with_attrs(
                Value::string(JsString::intern("")),
                PropertyAttributes::builtin_method(),
            ),
        );

        // Error.prototype.toString
        self.error_prototype.define_property(
            PropertyKey::string("toString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    if let Some(obj) = this_val.as_object() {
                        let name = obj
                            .get(&PropertyKey::string("name"))
                            .and_then(|v| v.as_string())
                            .map(|s| s.as_str().to_string())
                            .unwrap_or_else(|| "Error".to_string());
                        let msg = obj
                            .get(&PropertyKey::string("message"))
                            .and_then(|v| v.as_string())
                            .map(|s| s.as_str().to_string())
                            .unwrap_or_default();
                        if msg.is_empty() {
                            Ok(Value::string(JsString::intern(&name)))
                        } else {
                            Ok(Value::string(JsString::intern(&format!(
                                "{}: {}",
                                name, msg
                            ))))
                        }
                    } else {
                        Ok(Value::string(JsString::intern("Error")))
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Error type-specific names
        let error_names = [
            (self.type_error_prototype, "TypeError"),
            (self.range_error_prototype, "RangeError"),
            (self.reference_error_prototype, "ReferenceError"),
            (self.syntax_error_prototype, "SyntaxError"),
            (self.uri_error_prototype, "URIError"),
            (self.eval_error_prototype, "EvalError"),
        ];
        for (proto, name) in &error_names {
            proto.define_property(
                PropertyKey::string("name"),
                PropertyDescriptor::data_with_attrs(
                    Value::string(JsString::intern(name)),
                    PropertyAttributes::builtin_method(),
                ),
            );
            proto.define_property(
                PropertyKey::string("message"),
                PropertyDescriptor::data_with_attrs(
                    Value::string(JsString::intern("")),
                    PropertyAttributes::builtin_method(),
                ),
            );
        }

        // ====================================================================
        // Object static methods (on Object constructor, non-enumerable)
        // ====================================================================
        let obj_ctor = self.object_constructor;

        // Object.getPrototypeOf
        obj_ctor.define_property(
            PropertyKey::string("getPrototypeOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    if let Some(obj) = args.first().and_then(|v| v.as_object()) {
                        match obj.prototype() {
                            Some(proto) => Ok(Value::object(proto)),
                            None => Ok(Value::null()),
                        }
                    } else {
                        Ok(Value::null())
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.setPrototypeOf
        obj_ctor.define_property(
            PropertyKey::string("setPrototypeOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let target = args.first().cloned().unwrap_or(Value::undefined());
                    if let Some(obj) = target.as_object() {
                        let proto_val = args.get(1).cloned().unwrap_or(Value::undefined());
                        let proto = if proto_val.is_null() {
                            None
                        } else {
                            proto_val.as_object()
                        };
                        if !obj.set_prototype(proto) {
                            return Err(
                                "TypeError: Object.setPrototypeOf failed".to_string()
                            );
                        }
                    }
                    Ok(target)
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.getOwnPropertyDescriptor
        obj_ctor.define_property(
            PropertyKey::string("getOwnPropertyDescriptor"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, mm_inner| {
                    let target = args.first().and_then(|v| v.as_object());
                    let key = args.get(1).and_then(|v| v.as_string());
                    if let (Some(obj), Some(key_str)) = (target, key) {
                        let pk = PropertyKey::string(key_str.as_str());
                        if let Some(desc) = obj.get_own_property_descriptor(&pk) {
                            // Build descriptor object
                            let desc_obj =
                                GcRef::new(JsObject::new(None, mm_inner));
                            match &desc {
                                PropertyDescriptor::Data { value, attributes } => {
                                    desc_obj.set(
                                        PropertyKey::string("value"),
                                        value.clone(),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("writable"),
                                        Value::boolean(attributes.writable),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("enumerable"),
                                        Value::boolean(attributes.enumerable),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("configurable"),
                                        Value::boolean(attributes.configurable),
                                    );
                                }
                                PropertyDescriptor::Accessor {
                                    get,
                                    set,
                                    attributes,
                                } => {
                                    desc_obj.set(
                                        PropertyKey::string("get"),
                                        get.clone().unwrap_or(Value::undefined()),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("set"),
                                        set.clone().unwrap_or(Value::undefined()),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("enumerable"),
                                        Value::boolean(attributes.enumerable),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("configurable"),
                                        Value::boolean(attributes.configurable),
                                    );
                                }
                                PropertyDescriptor::Deleted => {}
                            }
                            return Ok(Value::object(desc_obj));
                        }
                    }
                    Ok(Value::undefined())
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.keys
        obj_ctor.define_property(
            PropertyKey::string("keys"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let obj = args
                        .first()
                        .and_then(|v| v.as_object())
                        .ok_or_else(|| "Object.keys requires an object".to_string())?;
                    let keys = obj.own_keys();
                    let mut names = Vec::new();
                    for key in keys {
                        match &key {
                            PropertyKey::String(s) => {
                                if let Some(desc) = obj.get_own_property_descriptor(&key) {
                                    if desc.enumerable() {
                                        names.push(Value::string(s.clone()));
                                    }
                                }
                            }
                            PropertyKey::Index(i) => {
                                if let Some(desc) = obj.get_own_property_descriptor(&key) {
                                    if desc.enumerable() {
                                        names.push(Value::string(JsString::intern(
                                            &i.to_string(),
                                        )));
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    let result = GcRef::new(JsObject::array(names.len(), _mm));
                    for (i, name) in names.into_iter().enumerate() {
                        result.set(PropertyKey::Index(i as u32), name);
                    }
                    Ok(Value::array(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.values
        obj_ctor.define_property(
            PropertyKey::string("values"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let obj = args
                        .first()
                        .and_then(|v| v.as_object())
                        .ok_or_else(|| "Object.values requires an object".to_string())?;
                    let keys = obj.own_keys();
                    let mut values = Vec::new();
                    for key in keys {
                        if let Some(desc) = obj.get_own_property_descriptor(&key) {
                            if desc.enumerable() {
                                if let Some(value) = obj.get(&key) {
                                    values.push(value);
                                }
                            }
                        }
                    }
                    let result = GcRef::new(JsObject::array(values.len(), _mm));
                    for (i, value) in values.into_iter().enumerate() {
                        result.set(PropertyKey::Index(i as u32), value);
                    }
                    Ok(Value::array(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.entries
        obj_ctor.define_property(
            PropertyKey::string("entries"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, mm_inner| {
                    let obj = args
                        .first()
                        .and_then(|v| v.as_object())
                        .ok_or_else(|| "Object.entries requires an object".to_string())?;
                    let keys = obj.own_keys();
                    let mut entries = Vec::new();
                    for key in keys {
                        if let Some(desc) = obj.get_own_property_descriptor(&key) {
                            if desc.enumerable() {
                                if let Some(value) = obj.get(&key) {
                                    let key_str = match &key {
                                        PropertyKey::String(s) => Value::string(s.clone()),
                                        PropertyKey::Index(i) => {
                                            Value::string(JsString::intern(&i.to_string()))
                                        }
                                        _ => continue,
                                    };
                                    let entry = GcRef::new(JsObject::array(
                                        2,
                                        mm_inner.clone(),
                                    ));
                                    entry.set(PropertyKey::Index(0), key_str);
                                    entry.set(PropertyKey::Index(1), value);
                                    entries.push(Value::array(entry));
                                }
                            }
                        }
                    }
                    let result =
                        GcRef::new(JsObject::array(entries.len(), mm_inner));
                    for (i, entry) in entries.into_iter().enumerate() {
                        result.set(PropertyKey::Index(i as u32), entry);
                    }
                    Ok(Value::array(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.assign
        obj_ctor.define_property(
            PropertyKey::string("assign"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let target_val = args
                        .first()
                        .ok_or_else(|| {
                            "Object.assign requires at least one argument".to_string()
                        })?;
                    let target = target_val
                        .as_object()
                        .ok_or_else(|| "Object.assign target must be an object".to_string())?;
                    for source_val in &args[1..] {
                        if source_val.is_null() || source_val.is_undefined() {
                            continue;
                        }
                        if let Some(source) = source_val.as_object() {
                            for key in source.own_keys() {
                                if let Some(desc) = source.get_own_property_descriptor(&key) {
                                    if desc.enumerable() {
                                        if let Some(value) = source.get(&key) {
                                            target.set(key, value);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    Ok(target_val.clone())
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.hasOwn
        obj_ctor.define_property(
            PropertyKey::string("hasOwn"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let obj = args
                        .first()
                        .and_then(|v| v.as_object())
                        .ok_or_else(|| "Object.hasOwn requires an object".to_string())?;
                    let prop = args.get(1).ok_or_else(|| {
                        "Object.hasOwn requires a property key".to_string()
                    })?;
                    let key = if let Some(s) = prop.as_string() {
                        PropertyKey::String(s)
                    } else if let Some(sym) = prop.as_symbol() {
                        PropertyKey::Symbol(sym.id)
                    } else if let Some(n) = prop.as_number() {
                        if n.fract() == 0.0 && n >= 0.0 && n <= u32::MAX as f64 {
                            PropertyKey::Index(n as u32)
                        } else {
                            PropertyKey::String(JsString::intern(&n.to_string()))
                        }
                    } else {
                        PropertyKey::String(JsString::intern("undefined"))
                    };
                    Ok(Value::boolean(obj.has_own(&key)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.freeze
        obj_ctor.define_property(
            PropertyKey::string("freeze"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let obj_val = args.first().cloned().unwrap_or(Value::undefined());
                    if let Some(obj) = obj_val.as_object() {
                        obj.freeze();
                    }
                    Ok(obj_val)
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.isFrozen
        obj_ctor.define_property(
            PropertyKey::string("isFrozen"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let is_frozen = args
                        .first()
                        .and_then(|v| v.as_object())
                        .map(|o| o.is_frozen())
                        .unwrap_or(true);
                    Ok(Value::boolean(is_frozen))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.seal
        obj_ctor.define_property(
            PropertyKey::string("seal"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let obj_val = args.first().cloned().unwrap_or(Value::undefined());
                    if let Some(obj) = obj_val.as_object() {
                        obj.seal();
                    }
                    Ok(obj_val)
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.isSealed
        obj_ctor.define_property(
            PropertyKey::string("isSealed"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let is_sealed = args
                        .first()
                        .and_then(|v| v.as_object())
                        .map(|o| o.is_sealed())
                        .unwrap_or(true);
                    Ok(Value::boolean(is_sealed))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.preventExtensions
        obj_ctor.define_property(
            PropertyKey::string("preventExtensions"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let obj_val = args.first().cloned().unwrap_or(Value::undefined());
                    if let Some(obj) = obj_val.as_object() {
                        obj.prevent_extensions();
                    }
                    Ok(obj_val)
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.isExtensible
        obj_ctor.define_property(
            PropertyKey::string("isExtensible"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let is_extensible = args
                        .first()
                        .and_then(|v| v.as_object())
                        .map(|o| o.is_extensible())
                        .unwrap_or(false);
                    Ok(Value::boolean(is_extensible))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.defineProperty
        obj_ctor.define_property(
            PropertyKey::string("defineProperty"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let obj_val = args
                        .first()
                        .ok_or_else(|| "Object.defineProperty requires an object".to_string())?;
                    let obj = obj_val.as_object().ok_or_else(|| {
                        "Object.defineProperty first argument must be an object".to_string()
                    })?;
                    let key_val = args
                        .get(1)
                        .ok_or_else(|| {
                            "Object.defineProperty requires a property key".to_string()
                        })?;
                    let descriptor = args
                        .get(2)
                        .ok_or_else(|| {
                            "Object.defineProperty requires a descriptor".to_string()
                        })?;

                    // Convert key
                    let key = if let Some(s) = key_val.as_string() {
                        PropertyKey::String(s)
                    } else if let Some(sym) = key_val.as_symbol() {
                        PropertyKey::Symbol(sym.id)
                    } else if let Some(n) = key_val.as_number() {
                        if n.fract() == 0.0 && n >= 0.0 && n <= u32::MAX as f64 {
                            PropertyKey::Index(n as u32)
                        } else {
                            PropertyKey::String(JsString::intern(&n.to_string()))
                        }
                    } else {
                        PropertyKey::String(JsString::intern("undefined"))
                    };

                    let attr_obj = descriptor.as_object().ok_or_else(|| {
                        "Property descriptor must be an object".to_string()
                    })?;

                    let read_bool = |name: &str, default: bool| -> bool {
                        attr_obj
                            .get(&PropertyKey::from(name))
                            .and_then(|v| v.as_boolean())
                            .unwrap_or(default)
                    };

                    let get = attr_obj.get(&PropertyKey::from("get"));
                    let set = attr_obj.get(&PropertyKey::from("set"));

                    if get.is_some() || set.is_some() {
                        let enumerable = read_bool("enumerable", false);
                        let configurable = read_bool("configurable", false);

                        let existing = obj.get_own_property_descriptor(&key);
                        let (mut existing_get, mut existing_set) = match existing {
                            Some(PropertyDescriptor::Accessor { get, set, .. }) => {
                                (get, set)
                            }
                            _ => (None, None),
                        };
                        let get = get
                            .filter(|v| !v.is_undefined())
                            .or_else(|| existing_get.take());
                        let set = set
                            .filter(|v| !v.is_undefined())
                            .or_else(|| existing_set.take());

                        obj.define_property(
                            key,
                            PropertyDescriptor::Accessor {
                                get,
                                set,
                                attributes: PropertyAttributes {
                                    writable: false,
                                    enumerable,
                                    configurable,
                                },
                            },
                        );
                    } else {
                        let value = attr_obj
                            .get(&PropertyKey::from("value"))
                            .unwrap_or(Value::undefined());
                        let writable = read_bool("writable", false);
                        let enumerable = read_bool("enumerable", false);
                        let configurable = read_bool("configurable", false);

                        obj.define_property(
                            key,
                            PropertyDescriptor::data_with_attrs(
                                value,
                                PropertyAttributes {
                                    writable,
                                    enumerable,
                                    configurable,
                                },
                            ),
                        );
                    }
                    Ok(obj_val.clone())
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.create
        obj_ctor.define_property(
            PropertyKey::string("create"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, mm_inner| {
                    let proto_val = args.first().ok_or_else(|| {
                        "Object.create requires a prototype argument".to_string()
                    })?;
                    let prototype = if proto_val.is_null() {
                        None
                    } else if let Some(proto_obj) = proto_val.as_object() {
                        Some(proto_obj)
                    } else {
                        return Err(
                            "Object prototype may only be an Object or null".to_string()
                        );
                    };
                    let new_obj = GcRef::new(JsObject::new(prototype, mm_inner.clone()));

                    // Handle optional properties object (second argument)
                    if let Some(props_val) = args.get(1) {
                        if !props_val.is_undefined() {
                            let props = props_val.as_object().ok_or_else(|| {
                                "Properties argument must be an object".to_string()
                            })?;
                            for key in props.own_keys() {
                                if let Some(descriptor) = props.get(&key) {
                                    if let Some(attr_obj) = descriptor.as_object() {
                                        let read_bool =
                                            |name: &str, default: bool| -> bool {
                                                attr_obj
                                                    .get(&PropertyKey::from(name))
                                                    .and_then(|v| v.as_boolean())
                                                    .unwrap_or(default)
                                            };
                                        let get =
                                            attr_obj.get(&PropertyKey::from("get"));
                                        let set =
                                            attr_obj.get(&PropertyKey::from("set"));
                                        if get.is_some() || set.is_some() {
                                            let enumerable =
                                                read_bool("enumerable", false);
                                            let configurable =
                                                read_bool("configurable", false);
                                            new_obj.define_property(
                                                key,
                                                PropertyDescriptor::Accessor {
                                                    get: get
                                                        .filter(|v| !v.is_undefined()),
                                                    set: set
                                                        .filter(|v| !v.is_undefined()),
                                                    attributes: PropertyAttributes {
                                                        writable: false,
                                                        enumerable,
                                                        configurable,
                                                    },
                                                },
                                            );
                                        } else {
                                            let value = attr_obj
                                                .get(&PropertyKey::from("value"))
                                                .unwrap_or(Value::undefined());
                                            let writable =
                                                read_bool("writable", false);
                                            let enumerable =
                                                read_bool("enumerable", false);
                                            let configurable =
                                                read_bool("configurable", false);
                                            new_obj.define_property(
                                                key,
                                                PropertyDescriptor::data_with_attrs(
                                                    value,
                                                    PropertyAttributes {
                                                        writable,
                                                        enumerable,
                                                        configurable,
                                                    },
                                                ),
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }

                    Ok(Value::object(new_obj))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.is (SameValue algorithm)
        obj_ctor.define_property(
            PropertyKey::string("is"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let v1 = args.first().cloned().unwrap_or(Value::undefined());
                    let v2 = args.get(1).cloned().unwrap_or(Value::undefined());
                    let result =
                        if let (Some(n1), Some(n2)) = (v1.as_number(), v2.as_number()) {
                            if n1.is_nan() && n2.is_nan() {
                                true
                            } else if n1 == 0.0 && n2 == 0.0 {
                                (1.0_f64 / n1).is_sign_positive()
                                    == (1.0_f64 / n2).is_sign_positive()
                            } else {
                                n1 == n2
                            }
                        } else if v1.is_undefined() && v2.is_undefined() {
                            true
                        } else if v1.is_null() && v2.is_null() {
                            true
                        } else if let (Some(b1), Some(b2)) =
                            (v1.as_boolean(), v2.as_boolean())
                        {
                            b1 == b2
                        } else if let (Some(s1), Some(s2)) =
                            (v1.as_string(), v2.as_string())
                        {
                            s1.as_str() == s2.as_str()
                        } else if let (Some(sym1), Some(sym2)) =
                            (v1.as_symbol(), v2.as_symbol())
                        {
                            sym1.id == sym2.id
                        } else if let (Some(o1), Some(o2)) =
                            (v1.as_object(), v2.as_object())
                        {
                            o1.as_ptr() == o2.as_ptr()
                        } else {
                            false
                        };
                    Ok(Value::boolean(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.getOwnPropertyNames
        obj_ctor.define_property(
            PropertyKey::string("getOwnPropertyNames"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, mm_inner| {
                    let obj = match args.first().and_then(|v| v.as_object()) {
                        Some(o) => o,
                        None => {
                            return Ok(Value::array(GcRef::new(JsObject::array(
                                0, mm_inner,
                            ))));
                        }
                    };
                    let keys = obj.own_keys();
                    let mut names = Vec::new();
                    for key in keys {
                        match key {
                            PropertyKey::String(s) => names.push(Value::string(s)),
                            PropertyKey::Index(i) => {
                                names.push(Value::string(JsString::intern(
                                    &i.to_string(),
                                )));
                            }
                            _ => {} // skip symbols
                        }
                    }
                    let result =
                        GcRef::new(JsObject::array(names.len(), mm_inner));
                    for (i, name) in names.into_iter().enumerate() {
                        result.set(PropertyKey::Index(i as u32), name);
                    }
                    Ok(Value::array(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.getOwnPropertyDescriptors
        obj_ctor.define_property(
            PropertyKey::string("getOwnPropertyDescriptors"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, mm_inner| {
                    let obj = match args.first().and_then(|v| v.as_object()) {
                        Some(o) => o,
                        None => {
                            return Ok(Value::object(GcRef::new(JsObject::new(
                                None, mm_inner,
                            ))));
                        }
                    };
                    let result = GcRef::new(JsObject::new(None, mm_inner.clone()));
                    for key in obj.own_keys() {
                        if let Some(desc) = obj.get_own_property_descriptor(&key) {
                            let desc_obj =
                                GcRef::new(JsObject::new(None, mm_inner.clone()));
                            match &desc {
                                PropertyDescriptor::Data { value, attributes } => {
                                    desc_obj.set(
                                        PropertyKey::string("value"),
                                        value.clone(),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("writable"),
                                        Value::boolean(attributes.writable),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("enumerable"),
                                        Value::boolean(attributes.enumerable),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("configurable"),
                                        Value::boolean(attributes.configurable),
                                    );
                                }
                                PropertyDescriptor::Accessor {
                                    get,
                                    set,
                                    attributes,
                                } => {
                                    desc_obj.set(
                                        PropertyKey::string("get"),
                                        get.clone()
                                            .unwrap_or(Value::undefined()),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("set"),
                                        set.clone()
                                            .unwrap_or(Value::undefined()),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("enumerable"),
                                        Value::boolean(attributes.enumerable),
                                    );
                                    desc_obj.set(
                                        PropertyKey::string("configurable"),
                                        Value::boolean(attributes.configurable),
                                    );
                                }
                                PropertyDescriptor::Deleted => {}
                            }
                            result.set(key, Value::object(desc_obj));
                        }
                    }
                    Ok(Value::object(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.defineProperties
        obj_ctor.define_property(
            PropertyKey::string("defineProperties"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let obj_val = args
                        .first()
                        .ok_or_else(|| {
                            "Object.defineProperties requires an object".to_string()
                        })?;
                    let obj = obj_val.as_object().ok_or_else(|| {
                        "Object.defineProperties first argument must be an object"
                            .to_string()
                    })?;
                    let props_val = args.get(1).ok_or_else(|| {
                        "Object.defineProperties requires properties".to_string()
                    })?;
                    let props = props_val.as_object().ok_or_else(|| {
                        "Object.defineProperties second argument must be an object"
                            .to_string()
                    })?;

                    for key in props.own_keys() {
                        if let Some(descriptor) = props.get(&key) {
                            if let Some(attr_obj) = descriptor.as_object() {
                                let read_bool =
                                    |name: &str, default: bool| -> bool {
                                        attr_obj
                                            .get(&PropertyKey::from(name))
                                            .and_then(|v| v.as_boolean())
                                            .unwrap_or(default)
                                    };
                                let get = attr_obj.get(&PropertyKey::from("get"));
                                let set = attr_obj.get(&PropertyKey::from("set"));
                                if get.is_some() || set.is_some() {
                                    let enumerable =
                                        read_bool("enumerable", false);
                                    let configurable =
                                        read_bool("configurable", false);
                                    obj.define_property(
                                        key,
                                        PropertyDescriptor::Accessor {
                                            get: get
                                                .filter(|v| !v.is_undefined()),
                                            set: set
                                                .filter(|v| !v.is_undefined()),
                                            attributes: PropertyAttributes {
                                                writable: false,
                                                enumerable,
                                                configurable,
                                            },
                                        },
                                    );
                                } else {
                                    let value = attr_obj
                                        .get(&PropertyKey::from("value"))
                                        .unwrap_or(Value::undefined());
                                    let writable = read_bool("writable", false);
                                    let enumerable =
                                        read_bool("enumerable", false);
                                    let configurable =
                                        read_bool("configurable", false);
                                    obj.define_property(
                                        key,
                                        PropertyDescriptor::data_with_attrs(
                                            value,
                                            PropertyAttributes {
                                                writable,
                                                enumerable,
                                                configurable,
                                            },
                                        ),
                                    );
                                }
                            }
                        }
                    }
                    Ok(obj_val.clone())
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Object.fromEntries
        obj_ctor.define_property(
            PropertyKey::string("fromEntries"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, mm_inner| {
                    let iterable = args.first().ok_or_else(|| {
                        "Object.fromEntries requires an iterable".to_string()
                    })?;
                    let iter_obj = iterable.as_object().ok_or_else(|| {
                        "Object.fromEntries argument must be iterable".to_string()
                    })?;
                    let result = GcRef::new(JsObject::new(None, mm_inner));

                    // Support array-like iterables (check length property)
                    if let Some(len_val) =
                        iter_obj.get(&PropertyKey::String(JsString::intern("length")))
                    {
                        if let Some(len) = len_val.as_number() {
                            for i in 0..(len as u32) {
                                if let Some(entry) =
                                    iter_obj.get(&PropertyKey::Index(i))
                                {
                                    if let Some(entry_obj) = entry.as_object() {
                                        let key = entry_obj
                                            .get(&PropertyKey::Index(0))
                                            .unwrap_or(Value::undefined());
                                        let value = entry_obj
                                            .get(&PropertyKey::Index(1))
                                            .unwrap_or(Value::undefined());
                                        let pk = if let Some(s) = key.as_string() {
                                            PropertyKey::String(s)
                                        } else if let Some(n) = key.as_number() {
                                            PropertyKey::String(JsString::intern(
                                                &n.to_string(),
                                            ))
                                        } else {
                                            PropertyKey::String(JsString::intern(
                                                "undefined",
                                            ))
                                        };
                                        result.set(pk, value);
                                    }
                                }
                            }
                        }
                    }
                    Ok(Value::object(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // ====================================================================
        // String.prototype core methods (non-enumerable)
        // ====================================================================
        self.string_prototype.define_property(
            PropertyKey::string("toString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    if let Some(s) = this_val.as_string() {
                        Ok(Value::string(s))
                    } else {
                        Ok(Value::string(JsString::intern(&format!("{:?}", this_val))))
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );
        self.string_prototype.define_property(
            PropertyKey::string("valueOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| Ok(this_val.clone()),
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.length (getter)
        self.string_prototype.define_property(
            PropertyKey::string("length"),
            PropertyDescriptor::getter(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    if let Some(s) = this_val.as_string() {
                        Ok(Value::number(s.as_str().len() as f64))
                    } else {
                        Ok(Value::number(0.0))
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.charAt
        self.string_prototype.define_property(
            PropertyKey::string("charAt"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.charAt: not a string".to_string())?;
                    let pos = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as usize;
                    let chars: Vec<char> = s.as_str().chars().collect();
                    if pos < chars.len() {
                        Ok(Value::string(JsString::intern(&chars[pos].to_string())))
                    } else {
                        Ok(Value::string(JsString::intern("")))
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.charCodeAt
        self.string_prototype.define_property(
            PropertyKey::string("charCodeAt"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.charCodeAt: not a string".to_string())?;
                    let pos = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as usize;
                    let chars: Vec<char> = s.as_str().chars().collect();
                    if pos < chars.len() {
                        Ok(Value::number(chars[pos] as u32 as f64))
                    } else {
                        Ok(Value::number(f64::NAN))
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.slice
        self.string_prototype.define_property(
            PropertyKey::string("slice"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.slice: not a string".to_string())?;
                    let str_val = s.as_str();
                    let len = str_val.len() as i64;
                    let start = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as i64;
                    let end = args
                        .get(1)
                        .and_then(|v| {
                            if v.is_undefined() {
                                None
                            } else {
                                v.as_number()
                            }
                        })
                        .unwrap_or(len as f64) as i64;
                    let from = if start < 0 {
                        (len + start).max(0)
                    } else {
                        start.min(len)
                    } as usize;
                    let to = if end < 0 {
                        (len + end).max(0)
                    } else {
                        end.min(len)
                    } as usize;
                    if to > from {
                        Ok(Value::string(JsString::intern(&str_val[from..to])))
                    } else {
                        Ok(Value::string(JsString::intern("")))
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.substring
        self.string_prototype.define_property(
            PropertyKey::string("substring"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.substring: not a string".to_string())?;
                    let str_val = s.as_str();
                    let len = str_val.len();
                    let start = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0)
                        .max(0.0) as usize;
                    let end = args
                        .get(1)
                        .and_then(|v| {
                            if v.is_undefined() {
                                None
                            } else {
                                v.as_number()
                            }
                        })
                        .unwrap_or(len as f64)
                        .max(0.0) as usize;
                    let from = start.min(end).min(len);
                    let to = start.max(end).min(len);
                    Ok(Value::string(JsString::intern(&str_val[from..to])))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.toLowerCase
        self.string_prototype.define_property(
            PropertyKey::string("toLowerCase"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.toLowerCase: not a string".to_string())?;
                    Ok(Value::string(JsString::intern(&s.as_str().to_lowercase())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.toUpperCase
        self.string_prototype.define_property(
            PropertyKey::string("toUpperCase"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.toUpperCase: not a string".to_string())?;
                    Ok(Value::string(JsString::intern(&s.as_str().to_uppercase())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.trim
        self.string_prototype.define_property(
            PropertyKey::string("trim"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.trim: not a string".to_string())?;
                    Ok(Value::string(JsString::intern(s.as_str().trim())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.trimStart (ES2019)
        self.string_prototype.define_property(
            PropertyKey::string("trimStart"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.trimStart: not a string".to_string())?;
                    Ok(Value::string(JsString::intern(s.as_str().trim_start())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.trimEnd (ES2019)
        self.string_prototype.define_property(
            PropertyKey::string("trimEnd"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.trimEnd: not a string".to_string())?;
                    Ok(Value::string(JsString::intern(s.as_str().trim_end())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.startsWith (ES2015)
        self.string_prototype.define_property(
            PropertyKey::string("startsWith"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.startsWith: not a string".to_string())?;
                    let search = args
                        .first()
                        .and_then(|v| v.as_string())
                        .ok_or_else(|| "startsWith requires a search string".to_string())?;
                    let pos = args
                        .get(1)
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0)
                        .max(0.0) as usize;
                    let str_val = s.as_str();
                    if pos > str_val.len() {
                        return Ok(Value::boolean(false));
                    }
                    Ok(Value::boolean(str_val[pos..].starts_with(search.as_str())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.endsWith (ES2015)
        self.string_prototype.define_property(
            PropertyKey::string("endsWith"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.endsWith: not a string".to_string())?;
                    let search = args
                        .first()
                        .and_then(|v| v.as_string())
                        .ok_or_else(|| "endsWith requires a search string".to_string())?;
                    let str_val = s.as_str();
                    let len = str_val.len();
                    let end_pos = args
                        .get(1)
                        .and_then(|v| {
                            if v.is_undefined() {
                                None
                            } else {
                                v.as_number()
                            }
                        })
                        .unwrap_or(len as f64) as usize;
                    let pos = end_pos.min(len);
                    Ok(Value::boolean(str_val[..pos].ends_with(search.as_str())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.includes (ES2015)
        self.string_prototype.define_property(
            PropertyKey::string("includes"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.includes: not a string".to_string())?;
                    let search = args
                        .first()
                        .and_then(|v| v.as_string())
                        .ok_or_else(|| "includes requires a search string".to_string())?;
                    let pos = args
                        .get(1)
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0)
                        .max(0.0) as usize;
                    let str_val = s.as_str();
                    if pos > str_val.len() {
                        return Ok(Value::boolean(false));
                    }
                    Ok(Value::boolean(str_val[pos..].contains(search.as_str())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.repeat (ES2015)
        self.string_prototype.define_property(
            PropertyKey::string("repeat"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.repeat: not a string".to_string())?;
                    let count = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0);
                    if count < 0.0 || count.is_infinite() {
                        return Err("RangeError: Invalid count".to_string());
                    }
                    let n = count as usize;
                    Ok(Value::string(JsString::intern(&s.as_str().repeat(n))))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.padStart (ES2017)
        self.string_prototype.define_property(
            PropertyKey::string("padStart"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.padStart: not a string".to_string())?;
                    let target_len = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as usize;
                    let str_val = s.as_str();
                    if target_len <= str_val.len() {
                        return Ok(Value::string(s));
                    }
                    let fill_str = args
                        .get(1)
                        .and_then(|v| {
                            if v.is_undefined() {
                                None
                            } else {
                                v.as_string()
                            }
                        })
                        .map(|s| s.as_str().to_string())
                        .unwrap_or_else(|| " ".to_string());
                    if fill_str.is_empty() {
                        return Ok(Value::string(s));
                    }
                    let pad_len = target_len - str_val.len();
                    let pad = fill_str.repeat((pad_len / fill_str.len()) + 1);
                    let result = format!("{}{}", &pad[..pad_len], str_val);
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.padEnd (ES2017)
        self.string_prototype.define_property(
            PropertyKey::string("padEnd"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.padEnd: not a string".to_string())?;
                    let target_len = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as usize;
                    let str_val = s.as_str();
                    if target_len <= str_val.len() {
                        return Ok(Value::string(s));
                    }
                    let fill_str = args
                        .get(1)
                        .and_then(|v| {
                            if v.is_undefined() {
                                None
                            } else {
                                v.as_string()
                            }
                        })
                        .map(|s| s.as_str().to_string())
                        .unwrap_or_else(|| " ".to_string());
                    if fill_str.is_empty() {
                        return Ok(Value::string(s));
                    }
                    let pad_len = target_len - str_val.len();
                    let pad = fill_str.repeat((pad_len / fill_str.len()) + 1);
                    let result = format!("{}{}", str_val, &pad[..pad_len]);
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.at (ES2022)
        self.string_prototype.define_property(
            PropertyKey::string("at"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.at: not a string".to_string())?;
                    let chars: Vec<char> = s.as_str().chars().collect();
                    let len = chars.len() as i64;
                    let idx = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as i64;
                    let actual = if idx < 0 { len + idx } else { idx };
                    if actual < 0 || actual >= len {
                        return Ok(Value::undefined());
                    }
                    Ok(Value::string(JsString::intern(&chars[actual as usize].to_string())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.indexOf
        self.string_prototype.define_property(
            PropertyKey::string("indexOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.indexOf: not a string".to_string())?;
                    let search = args
                        .first()
                        .and_then(|v| v.as_string())
                        .ok_or_else(|| "indexOf requires a search string".to_string())?;
                    let from_index = args
                        .get(1)
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0)
                        .max(0.0) as usize;
                    let str_val = s.as_str();
                    if from_index >= str_val.len() {
                        return Ok(Value::number(-1.0));
                    }
                    match str_val[from_index..].find(search.as_str()) {
                        Some(pos) => Ok(Value::number((from_index + pos) as f64)),
                        None => Ok(Value::number(-1.0)),
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.lastIndexOf
        self.string_prototype.define_property(
            PropertyKey::string("lastIndexOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.lastIndexOf: not a string".to_string())?;
                    let search = args
                        .first()
                        .and_then(|v| v.as_string())
                        .ok_or_else(|| "lastIndexOf requires a search string".to_string())?;
                    let str_val = s.as_str();
                    match str_val.rfind(search.as_str()) {
                        Some(pos) => Ok(Value::number(pos as f64)),
                        None => Ok(Value::number(-1.0)),
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.concat
        self.string_prototype.define_property(
            PropertyKey::string("concat"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.concat: not a string".to_string())?;
                    let mut result = s.as_str().to_string();
                    for arg in args {
                        if let Some(s) = arg.as_string() {
                            result.push_str(s.as_str());
                        } else if let Some(n) = arg.as_number() {
                            result.push_str(&n.to_string());
                        } else if let Some(b) = arg.as_boolean() {
                            result.push_str(if b { "true" } else { "false" });
                        } else if arg.is_null() {
                            result.push_str("null");
                        } else if arg.is_undefined() {
                            result.push_str("undefined");
                        }
                    }
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.prototype.split
        self.string_prototype.define_property(
            PropertyKey::string("split"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, mm_inner| {
                    let s = this_val
                        .as_string()
                        .ok_or_else(|| "String.prototype.split: not a string".to_string())?;
                    let str_val = s.as_str();
                    let separator = args.first();
                    let limit = args
                        .get(1)
                        .and_then(|v| {
                            if v.is_undefined() {
                                None
                            } else {
                                v.as_number()
                            }
                        })
                        .map(|n| n as usize);

                    let parts: Vec<&str> = if let Some(sep) = separator {
                        if sep.is_undefined() {
                            vec![str_val]
                        } else if let Some(sep_str) = sep.as_string() {
                            if sep_str.as_str().is_empty() {
                                str_val.chars().map(|_| "").collect()
                            } else {
                                str_val.split(sep_str.as_str()).collect()
                            }
                        } else {
                            vec![str_val]
                        }
                    } else {
                        vec![str_val]
                    };

                    let result_len = limit.unwrap_or(parts.len()).min(parts.len());
                    let result = GcRef::new(JsObject::array(result_len, mm_inner));
                    for (i, part) in parts.iter().take(result_len).enumerate() {
                        result.set(
                            PropertyKey::Index(i as u32),
                            Value::string(JsString::intern(part)),
                        );
                    }
                    Ok(Value::array(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // ====================================================================
        // Number.prototype core methods
        // ====================================================================
        self.number_prototype.define_property(
            PropertyKey::string("valueOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| Ok(this_val.clone()),
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.prototype.toString([radix])
        self.number_prototype.define_property(
            PropertyKey::string("toString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let n = if let Some(num) = this_val.as_number() {
                        num
                    } else if let Some(i) = this_val.as_int32() {
                        i as f64
                    } else {
                        return Err("Number.prototype.toString requires a number".to_string());
                    };

                    let radix = args.first().and_then(|v| v.as_int32()).unwrap_or(10);
                    if radix < 2 || radix > 36 {
                        return Err("radix must be between 2 and 36".to_string());
                    }

                    let result = if n.is_nan() {
                        "NaN".to_string()
                    } else if n.is_infinite() {
                        if n.is_sign_positive() {
                            "Infinity".to_string()
                        } else {
                            "-Infinity".to_string()
                        }
                    } else if radix == 10 {
                        n.to_string()
                    } else if n.fract() == 0.0 && n.is_finite() {
                        let i = n as i64;
                        // Manual radix conversion
                        let is_negative = i < 0;
                        let mut num = i.abs() as u64;
                        let mut digits = Vec::new();
                        let radix_u = radix as u64;

                        if num == 0 {
                            "0".to_string()
                        } else {
                            while num > 0 {
                                let digit = (num % radix_u) as u8;
                                let ch = if digit < 10 {
                                    (b'0' + digit) as char
                                } else {
                                    (b'a' + (digit - 10)) as char
                                };
                                digits.push(ch);
                                num /= radix_u;
                            }
                            digits.reverse();
                            let mut result = String::new();
                            if is_negative {
                                result.push('-');
                            }
                            result.extend(digits);
                            result
                        }
                    } else {
                        // Fractional numbers: just return decimal for now
                        n.to_string()
                    };
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.prototype.toFixed(digits)
        self.number_prototype.define_property(
            PropertyKey::string("toFixed"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let n = if let Some(num) = this_val.as_number() {
                        num
                    } else if let Some(i) = this_val.as_int32() {
                        i as f64
                    } else {
                        return Err("Number.prototype.toFixed requires a number".to_string());
                    };

                    let digits = args
                        .first()
                        .and_then(|v| v.as_int32())
                        .unwrap_or(0)
                        .max(0)
                        .min(100) as usize;

                    if n.is_nan() {
                        return Ok(Value::string(JsString::intern("NaN")));
                    }
                    if n.is_infinite() {
                        return Ok(Value::string(JsString::intern(
                            if n.is_sign_positive() {
                                "Infinity"
                            } else {
                                "-Infinity"
                            },
                        )));
                    }

                    let result = format!("{:.prec$}", n, prec = digits);
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.prototype.toExponential(fractionDigits)
        self.number_prototype.define_property(
            PropertyKey::string("toExponential"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let n = if let Some(num) = this_val.as_number() {
                        num
                    } else if let Some(i) = this_val.as_int32() {
                        i as f64
                    } else {
                        return Err(
                            "Number.prototype.toExponential requires a number".to_string()
                        );
                    };

                    if n.is_nan() {
                        return Ok(Value::string(JsString::intern("NaN")));
                    }
                    if n.is_infinite() {
                        return Ok(Value::string(JsString::intern(
                            if n.is_sign_positive() {
                                "Infinity"
                            } else {
                                "-Infinity"
                            },
                        )));
                    }

                    let digits = args
                        .first()
                        .and_then(|v| v.as_int32())
                        .unwrap_or(0)
                        .max(0)
                        .min(100) as usize;

                    let result = format!("{:.prec$e}", n, prec = digits);
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.prototype.toPrecision(precision)
        self.number_prototype.define_property(
            PropertyKey::string("toPrecision"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let n = if let Some(num) = this_val.as_number() {
                        num
                    } else if let Some(i) = this_val.as_int32() {
                        i as f64
                    } else {
                        return Err(
                            "Number.prototype.toPrecision requires a number".to_string()
                        );
                    };

                    if args.is_empty() {
                        return Ok(Value::string(JsString::intern(&n.to_string())));
                    }

                    if n.is_nan() {
                        return Ok(Value::string(JsString::intern("NaN")));
                    }
                    if n.is_infinite() {
                        return Ok(Value::string(JsString::intern(
                            if n.is_sign_positive() {
                                "Infinity"
                            } else {
                                "-Infinity"
                            },
                        )));
                    }

                    let precision = args
                        .first()
                        .and_then(|v| v.as_int32())
                        .unwrap_or(1)
                        .max(1)
                        .min(100) as usize;

                    let result = format!("{:.prec$}", n, prec = precision - 1);
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.prototype.toLocaleString()
        self.number_prototype.define_property(
            PropertyKey::string("toLocaleString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let n = if let Some(num) = this_val.as_number() {
                        num
                    } else if let Some(i) = this_val.as_int32() {
                        i as f64
                    } else {
                        return Err(
                            "Number.prototype.toLocaleString requires a number".to_string()
                        );
                    };
                    // Simplified: just use toString for now
                    Ok(Value::string(JsString::intern(&n.to_string())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // ====================================================================
        // Boolean.prototype core methods
        // ====================================================================
        self.boolean_prototype.define_property(
            PropertyKey::string("valueOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| Ok(this_val.clone()),
                mm.clone(),
                fn_proto,
            )),
        );

        // ====================================================================
        // Date.prototype methods
        // ====================================================================
        // Date.prototype.getTime()
        self.date_prototype.define_property(
            PropertyKey::string("getTime"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n
                    } else if let Some(i) = ts_val.as_int32() {
                        i as f64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };
                    Ok(Value::number(ts))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.valueOf() - same as getTime()
        self.date_prototype.define_property(
            PropertyKey::string("valueOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n
                    } else if let Some(i) = ts_val.as_int32() {
                        i as f64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };
                    Ok(Value::number(ts))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toISOString()
        self.date_prototype.define_property(
            PropertyKey::string("toISOString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Utc};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs)
                        .ok_or("Invalid timestamp")?;

                    Ok(Value::string(JsString::intern(&dt.to_rfc3339())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toString()
        self.date_prototype.define_property(
            PropertyKey::string("toString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    let str = format!("{}", local_dt.format("%a %b %d %Y %H:%M:%S GMT%z"));
                    Ok(Value::string(JsString::intern(&str)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toDateString()
        self.date_prototype.define_property(
            PropertyKey::string("toDateString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    let str = format!("{}", local_dt.format("%a %b %d %Y"));
                    Ok(Value::string(JsString::intern(&str)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toTimeString()
        self.date_prototype.define_property(
            PropertyKey::string("toTimeString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    let str = format!("{}", local_dt.format("%H:%M:%S GMT%z"));
                    Ok(Value::string(JsString::intern(&str)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getFullYear()
        self.date_prototype.define_property(
            PropertyKey::string("getFullYear"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Datelike, Local};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    Ok(Value::int32(local_dt.year()))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getMonth()
        self.date_prototype.define_property(
            PropertyKey::string("getMonth"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Datelike, Local};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    Ok(Value::int32(local_dt.month() as i32 - 1)) // JS months are 0-indexed
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getDate()
        self.date_prototype.define_property(
            PropertyKey::string("getDate"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Datelike, Local};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    Ok(Value::int32(local_dt.day() as i32))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getHours()
        self.date_prototype.define_property(
            PropertyKey::string("getHours"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local, Timelike};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    Ok(Value::int32(local_dt.hour() as i32))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getMinutes()
        self.date_prototype.define_property(
            PropertyKey::string("getMinutes"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local, Timelike};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    Ok(Value::int32(local_dt.minute() as i32))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getSeconds()
        self.date_prototype.define_property(
            PropertyKey::string("getSeconds"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local, Timelike};

                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let secs = ts / 1000;
                    let nsecs = ((ts % 1000) * 1_000_000) as u32;
                    let dt = DateTime::from_timestamp(secs, nsecs).ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = dt.into();

                    Ok(Value::int32(local_dt.second() as i32))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getMilliseconds()
        self.date_prototype.define_property(
            PropertyKey::string("getMilliseconds"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    Ok(Value::int32((ts % 1000) as i32))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getDay()
        self.date_prototype.define_property(
            PropertyKey::string("getDay"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Datelike, Local};
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let dt = DateTime::from_timestamp(ts / 1000, ((ts % 1000) * 1_000_000) as u32)
                        .ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = DateTime::from(dt);
                    // Sunday = 0, Monday = 1, ..., Saturday = 6
                    let day = local_dt.weekday().num_days_from_sunday();
                    Ok(Value::int32(day as i32))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.getTimezoneOffset()
        self.date_prototype.define_property(
            PropertyKey::string("getTimezoneOffset"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local};
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let dt = DateTime::from_timestamp(ts / 1000, ((ts % 1000) * 1_000_000) as u32)
                        .ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = DateTime::from(dt);
                    // Returns difference in minutes from UTC (negative for ahead of UTC)
                    let offset_seconds = local_dt.offset().local_minus_utc();
                    let offset_minutes = -(offset_seconds / 60);
                    Ok(Value::int32(offset_minutes))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toJSON()
        self.date_prototype.define_property(
            PropertyKey::string("toJSON"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::DateTime;
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let dt = DateTime::from_timestamp(ts / 1000, ((ts % 1000) * 1_000_000) as u32)
                        .ok_or("Invalid timestamp")?;
                    Ok(Value::string(JsString::intern(&dt.to_rfc3339())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toUTCString()
        self.date_prototype.define_property(
            PropertyKey::string("toUTCString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::DateTime;
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let dt = DateTime::from_timestamp(ts / 1000, ((ts % 1000) * 1_000_000) as u32)
                        .ok_or("Invalid timestamp")?;
                    // RFC 2822 format: "Fri, 31 Jan 2026 09:30:00 GMT"
                    Ok(Value::string(JsString::intern(&dt.format("%a, %d %b %Y %H:%M:%S GMT").to_string())))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toLocaleDateString()
        self.date_prototype.define_property(
            PropertyKey::string("toLocaleDateString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local};
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let dt = DateTime::from_timestamp(ts / 1000, ((ts % 1000) * 1_000_000) as u32)
                        .ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = DateTime::from(dt);
                    // Simple US format: "1/31/2026"
                    Ok(Value::string(JsString::intern(&format!("{}/{}/{}", local_dt.month(), local_dt.day(), local_dt.year()))))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toLocaleTimeString()
        self.date_prototype.define_property(
            PropertyKey::string("toLocaleTimeString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Local, Timelike};
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let dt = DateTime::from_timestamp(ts / 1000, ((ts % 1000) * 1_000_000) as u32)
                        .ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = DateTime::from(dt);
                    // Simple 12-hour format: "9:30:00 AM"
                    let hour12 = if local_dt.hour() == 0 { 12 } else if local_dt.hour() > 12 { local_dt.hour() - 12 } else { local_dt.hour() };
                    let ampm = if local_dt.hour() < 12 { "AM" } else { "PM" };
                    Ok(Value::string(JsString::intern(&format!("{}:{:02}:{:02} {}", hour12, local_dt.minute(), local_dt.second(), ampm))))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.prototype.toLocaleString()
        self.date_prototype.define_property(
            PropertyKey::string("toLocaleString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    use chrono::{DateTime, Datelike, Local, Timelike};
                    let obj = this_val.as_object().ok_or("Date method requires a Date object")?;
                    let ts_val = obj.get(&PropertyKey::string("__timestamp__"))
                        .ok_or("Date object missing __timestamp__")?;
                    let ts = if let Some(n) = ts_val.as_number() {
                        n as i64
                    } else if let Some(i) = ts_val.as_int32() {
                        i as i64
                    } else {
                        return Err("Invalid timestamp".to_string());
                    };

                    let dt = DateTime::from_timestamp(ts / 1000, ((ts % 1000) * 1_000_000) as u32)
                        .ok_or("Invalid timestamp")?;
                    let local_dt: DateTime<Local> = DateTime::from(dt);
                    // Combined: "1/31/2026, 9:30:00 AM"
                    let hour12 = if local_dt.hour() == 0 { 12 } else if local_dt.hour() > 12 { local_dt.hour() - 12 } else { local_dt.hour() };
                    let ampm = if local_dt.hour() < 12 { "AM" } else { "PM" };
                    Ok(Value::string(JsString::intern(&format!("{}/{}/{}, {}:{:02}:{:02} {}",
                        local_dt.month(), local_dt.day(), local_dt.year(),
                        hour12, local_dt.minute(), local_dt.second(), ampm))))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // ====================================================================
        // Iterator prototype: [Symbol.iterator]() { return this; }
        // ====================================================================
        if let Some(sym) = self.symbol_iterator.as_symbol() {
            self.iterator_prototype.define_property(
                PropertyKey::Symbol(sym.id),
                PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                    |this_val, _args, _mm| Ok(this_val.clone()),
                    mm.clone(),
                    fn_proto,
                )),
            );
        }

        // ====================================================================
        // Array.prototype methods (non-enumerable)
        // ====================================================================
        let arr_proto = self.array_prototype;

        // Helper: get array length from an object
        fn get_len(obj: &GcRef<JsObject>) -> usize {
            obj.get(&PropertyKey::string("length"))
                .and_then(|v| v.as_number())
                .unwrap_or(0.0) as usize
        }
        fn set_len(obj: &GcRef<JsObject>, len: usize) {
            obj.set(PropertyKey::string("length"), Value::number(len as f64));
        }

        // Array.prototype.push
        arr_proto.define_property(
            PropertyKey::string("push"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.push: this is not an object".to_string())?;
                    let mut len = get_len(&obj);
                    for arg in args {
                        obj.set(PropertyKey::Index(len as u32), arg.clone());
                        len += 1;
                    }
                    set_len(&obj, len);
                    Ok(Value::number(len as f64))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.pop
        arr_proto.define_property(
            PropertyKey::string("pop"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.pop: this is not an object".to_string())?;
                    let len = get_len(&obj);
                    if len == 0 {
                        set_len(&obj, 0);
                        return Ok(Value::undefined());
                    }
                    let idx = PropertyKey::Index((len - 1) as u32);
                    let val = obj.get(&idx).unwrap_or(Value::undefined());
                    obj.delete(&idx);
                    set_len(&obj, len - 1);
                    Ok(val)
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.shift
        arr_proto.define_property(
            PropertyKey::string("shift"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.shift: not an object".to_string())?;
                    let len = get_len(&obj);
                    if len == 0 {
                        set_len(&obj, 0);
                        return Ok(Value::undefined());
                    }
                    let first = obj.get(&PropertyKey::Index(0)).unwrap_or(Value::undefined());
                    for i in 1..len {
                        let val = obj
                            .get(&PropertyKey::Index(i as u32))
                            .unwrap_or(Value::undefined());
                        obj.set(PropertyKey::Index((i - 1) as u32), val);
                    }
                    obj.delete(&PropertyKey::Index((len - 1) as u32));
                    set_len(&obj, len - 1);
                    Ok(first)
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.unshift
        arr_proto.define_property(
            PropertyKey::string("unshift"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.unshift: not an object".to_string())?;
                    let len = get_len(&obj);
                    let arg_count = args.len();
                    // Shift existing elements right
                    for i in (0..len).rev() {
                        let val = obj
                            .get(&PropertyKey::Index(i as u32))
                            .unwrap_or(Value::undefined());
                        obj.set(PropertyKey::Index((i + arg_count) as u32), val);
                    }
                    // Insert new elements at front
                    for (i, arg) in args.iter().enumerate() {
                        obj.set(PropertyKey::Index(i as u32), arg.clone());
                    }
                    let new_len = len + arg_count;
                    set_len(&obj, new_len);
                    Ok(Value::number(new_len as f64))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.indexOf
        arr_proto.define_property(
            PropertyKey::string("indexOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.indexOf: not an object".to_string())?;
                    let len = get_len(&obj);
                    let search = args.first().cloned().unwrap_or(Value::undefined());
                    let from = args
                        .get(1)
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as i64;
                    let start = if from < 0 {
                        (len as i64 + from).max(0) as usize
                    } else {
                        from as usize
                    };
                    for i in start..len {
                        if let Some(val) = obj.get(&PropertyKey::Index(i as u32)) {
                            if strict_equal(&val, &search) {
                                return Ok(Value::number(i as f64));
                            }
                        }
                    }
                    Ok(Value::number(-1.0))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.lastIndexOf
        arr_proto.define_property(
            PropertyKey::string("lastIndexOf"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.lastIndexOf: not an object".to_string())?;
                    let len = get_len(&obj);
                    if len == 0 {
                        return Ok(Value::number(-1.0));
                    }
                    let search = args.first().cloned().unwrap_or(Value::undefined());
                    let from = args
                        .get(1)
                        .and_then(|v| v.as_number())
                        .unwrap_or((len as f64) - 1.0) as i64;
                    let start = if from < 0 {
                        (len as i64 + from) as usize
                    } else {
                        from.min((len as i64) - 1) as usize
                    };
                    for i in (0..=start).rev() {
                        if let Some(val) = obj.get(&PropertyKey::Index(i as u32)) {
                            if strict_equal(&val, &search) {
                                return Ok(Value::number(i as f64));
                            }
                        }
                    }
                    Ok(Value::number(-1.0))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.includes
        arr_proto.define_property(
            PropertyKey::string("includes"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.includes: not an object".to_string())?;
                    let len = get_len(&obj);
                    let search = args.first().cloned().unwrap_or(Value::undefined());
                    let from = args
                        .get(1)
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as i64;
                    let start = if from < 0 {
                        (len as i64 + from).max(0) as usize
                    } else {
                        from as usize
                    };
                    for i in start..len {
                        if let Some(val) = obj.get(&PropertyKey::Index(i as u32)) {
                            if same_value_zero(&val, &search) {
                                return Ok(Value::boolean(true));
                            }
                        }
                    }
                    Ok(Value::boolean(false))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.join
        arr_proto.define_property(
            PropertyKey::string("join"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.join: not an object".to_string())?;
                    let len = get_len(&obj);
                    let sep = args
                        .first()
                        .and_then(|v| {
                            if v.is_undefined() {
                                None
                            } else {
                                v.as_string().map(|s| s.as_str().to_string())
                            }
                        })
                        .unwrap_or_else(|| ",".to_string());
                    let mut parts = Vec::with_capacity(len);
                    for i in 0..len {
                        let val = obj
                            .get(&PropertyKey::Index(i as u32))
                            .unwrap_or(Value::undefined());
                        if val.is_undefined() || val.is_null() {
                            parts.push(String::new());
                        } else if let Some(s) = val.as_string() {
                            parts.push(s.as_str().to_string());
                        } else if let Some(n) = val.as_number() {
                            if n.fract() == 0.0 && n.abs() < 1e15 {
                                parts.push(format!("{}", n as i64));
                            } else {
                                parts.push(format!("{}", n));
                            }
                        } else if let Some(b) = val.as_boolean() {
                            parts.push(if b { "true" } else { "false" }.to_string());
                        } else {
                            parts.push("[object Object]".to_string());
                        }
                    }
                    Ok(Value::string(JsString::intern(&parts.join(&sep))))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.toString
        arr_proto.define_property(
            PropertyKey::string("toString"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    // toString delegates to join
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.toString: not an object".to_string())?;
                    let len = get_len(&obj);
                    let mut parts = Vec::with_capacity(len);
                    for i in 0..len {
                        let val = obj
                            .get(&PropertyKey::Index(i as u32))
                            .unwrap_or(Value::undefined());
                        if val.is_undefined() || val.is_null() {
                            parts.push(String::new());
                        } else if let Some(s) = val.as_string() {
                            parts.push(s.as_str().to_string());
                        } else if let Some(n) = val.as_number() {
                            if n.fract() == 0.0 && n.abs() < 1e15 {
                                parts.push(format!("{}", n as i64));
                            } else {
                                parts.push(format!("{}", n));
                            }
                        } else if let Some(b) = val.as_boolean() {
                            parts.push(if b { "true" } else { "false" }.to_string());
                        } else {
                            parts.push("[object Object]".to_string());
                        }
                    }
                    Ok(Value::string(JsString::intern(&parts.join(","))))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.slice
        arr_proto.define_property(
            PropertyKey::string("slice"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, mm_inner| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.slice: not an object".to_string())?;
                    let len = get_len(&obj) as i64;
                    let start = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as i64;
                    let end = args
                        .get(1)
                        .and_then(|v| {
                            if v.is_undefined() {
                                None
                            } else {
                                v.as_number()
                            }
                        })
                        .unwrap_or(len as f64) as i64;
                    let from = if start < 0 { (len + start).max(0) } else { start.min(len) } as usize;
                    let to = if end < 0 { (len + end).max(0) } else { end.min(len) } as usize;
                    let count = if to > from { to - from } else { 0 };
                    let result = GcRef::new(JsObject::array(count, mm_inner));
                    for i in 0..count {
                        let val = obj
                            .get(&PropertyKey::Index((from + i) as u32))
                            .unwrap_or(Value::undefined());
                        result.set(PropertyKey::Index(i as u32), val);
                    }
                    Ok(Value::array(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.concat
        arr_proto.define_property(
            PropertyKey::string("concat"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, mm_inner| {
                    let result = GcRef::new(JsObject::array(0, mm_inner));
                    let mut idx: u32 = 0;
                    // Copy elements from this
                    if let Some(obj) = this_val.as_object() {
                        let len = get_len(&obj);
                        for i in 0..len {
                            if let Some(val) = obj.get(&PropertyKey::Index(i as u32)) {
                                result.set(PropertyKey::Index(idx), val);
                                idx += 1;
                            }
                        }
                    }
                    // Copy elements from each argument
                    for arg in args {
                        if let Some(arr) = arg.as_object() {
                            // Check if it's an array (has length)
                            if arr.get(&PropertyKey::string("length")).is_some() {
                                let len = get_len(&arr);
                                for i in 0..len {
                                    let val = arr
                                        .get(&PropertyKey::Index(i as u32))
                                        .unwrap_or(Value::undefined());
                                    result.set(PropertyKey::Index(idx), val);
                                    idx += 1;
                                }
                                continue;
                            }
                        }
                        // Non-array: push as single element
                        result.set(PropertyKey::Index(idx), arg.clone());
                        idx += 1;
                    }
                    set_len(&result, idx as usize);
                    Ok(Value::array(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.reverse
        arr_proto.define_property(
            PropertyKey::string("reverse"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, _args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.reverse: not an object".to_string())?;
                    let len = get_len(&obj);
                    let mut lo = 0usize;
                    let mut hi = if len > 0 { len - 1 } else { 0 };
                    while lo < hi {
                        let lo_val = obj
                            .get(&PropertyKey::Index(lo as u32))
                            .unwrap_or(Value::undefined());
                        let hi_val = obj
                            .get(&PropertyKey::Index(hi as u32))
                            .unwrap_or(Value::undefined());
                        obj.set(PropertyKey::Index(lo as u32), hi_val);
                        obj.set(PropertyKey::Index(hi as u32), lo_val);
                        lo += 1;
                        hi -= 1;
                    }
                    Ok(this_val.clone())
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.at
        arr_proto.define_property(
            PropertyKey::string("at"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.at: not an object".to_string())?;
                    let len = get_len(&obj) as i64;
                    let idx = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as i64;
                    let actual = if idx < 0 { len + idx } else { idx };
                    if actual < 0 || actual >= len {
                        return Ok(Value::undefined());
                    }
                    Ok(obj
                        .get(&PropertyKey::Index(actual as u32))
                        .unwrap_or(Value::undefined()))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.fill
        arr_proto.define_property(
            PropertyKey::string("fill"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, _mm| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.fill: not an object".to_string())?;
                    let len = get_len(&obj) as i64;
                    let value = args.first().cloned().unwrap_or(Value::undefined());
                    let start = args
                        .get(1)
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as i64;
                    let end = args
                        .get(2)
                        .and_then(|v| {
                            if v.is_undefined() { None } else { v.as_number() }
                        })
                        .unwrap_or(len as f64) as i64;
                    let from = if start < 0 { (len + start).max(0) } else { start.min(len) } as usize;
                    let to = if end < 0 { (len + end).max(0) } else { end.min(len) } as usize;
                    for i in from..to {
                        obj.set(PropertyKey::Index(i as u32), value.clone());
                    }
                    Ok(this_val.clone())
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.splice
        arr_proto.define_property(
            PropertyKey::string("splice"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, mm_inner| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.splice: not an object".to_string())?;
                    let len = get_len(&obj) as i64;
                    let start_raw = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(0.0) as i64;
                    let actual_start = if start_raw < 0 {
                        (len + start_raw).max(0)
                    } else {
                        start_raw.min(len)
                    } as usize;
                    let delete_count = args
                        .get(1)
                        .and_then(|v| v.as_number())
                        .map(|n| (n as i64).max(0).min(len - actual_start as i64) as usize)
                        .unwrap_or((len - actual_start as i64).max(0) as usize);
                    let items = if args.len() > 2 { &args[2..] } else { &[] };

                    // Collect removed elements
                    let removed = GcRef::new(JsObject::array(delete_count, mm_inner));
                    for i in 0..delete_count {
                        let val = obj
                            .get(&PropertyKey::Index((actual_start + i) as u32))
                            .unwrap_or(Value::undefined());
                        removed.set(PropertyKey::Index(i as u32), val);
                    }

                    let item_count = items.len();
                    let ulen = len as usize;

                    if item_count < delete_count {
                        // Shift elements left
                        let diff = delete_count - item_count;
                        for i in actual_start + delete_count..ulen {
                            let val = obj
                                .get(&PropertyKey::Index(i as u32))
                                .unwrap_or(Value::undefined());
                            obj.set(PropertyKey::Index((i - diff) as u32), val);
                        }
                        for i in (ulen - diff)..ulen {
                            obj.delete(&PropertyKey::Index(i as u32));
                        }
                    } else if item_count > delete_count {
                        // Shift elements right
                        let diff = item_count - delete_count;
                        for i in (actual_start + delete_count..ulen).rev() {
                            let val = obj
                                .get(&PropertyKey::Index(i as u32))
                                .unwrap_or(Value::undefined());
                            obj.set(PropertyKey::Index((i + diff) as u32), val);
                        }
                    }

                    // Insert new items
                    for (i, item) in items.iter().enumerate() {
                        obj.set(
                            PropertyKey::Index((actual_start + i) as u32),
                            item.clone(),
                        );
                    }

                    let new_len = ulen - delete_count + item_count;
                    set_len(&obj, new_len);
                    Ok(Value::array(removed))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.prototype.flat (depth = 1 by default)
        arr_proto.define_property(
            PropertyKey::string("flat"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |this_val, args, mm_inner| {
                    let obj = this_val
                        .as_object()
                        .ok_or_else(|| "Array.prototype.flat: not an object".to_string())?;
                    let depth = args
                        .first()
                        .and_then(|v| v.as_number())
                        .unwrap_or(1.0) as i32;

                    fn flatten(
                        source: &GcRef<JsObject>,
                        depth: i32,
                        result: &mut Vec<Value>,
                    ) {
                        let len = get_len(source);
                        for i in 0..len {
                            if let Some(val) = source.get(&PropertyKey::Index(i as u32)) {
                                if depth > 0 {
                                    if let Some(inner) = val.as_object() {
                                        if inner
                                            .get(&PropertyKey::string("length"))
                                            .is_some()
                                        {
                                            flatten(&inner, depth - 1, result);
                                            continue;
                                        }
                                    }
                                }
                                result.push(val);
                            }
                        }
                    }

                    let mut items = Vec::new();
                    flatten(&obj, depth, &mut items);
                    let result_arr =
                        GcRef::new(JsObject::array(items.len(), mm_inner));
                    for (i, item) in items.into_iter().enumerate() {
                        result_arr.set(PropertyKey::Index(i as u32), item);
                    }
                    Ok(Value::array(result_arr))
                },
                mm.clone(),
                fn_proto,
            )),
        );
    }

    /// Install intrinsic constructors on the global object.
    ///
    /// This creates constructor Values (native functions) backed by the intrinsic
    /// objects and installs them as global properties. Call after `init_core()`.
    pub fn install_on_global(&self, global: GcRef<JsObject>, mm: &Arc<MemoryManager>) {
        use crate::object::{PropertyAttributes, PropertyDescriptor, PropertyKey};
        use crate::string::JsString;

        let fn_proto = self.function_prototype;

        // Helper: install a constructor+prototype pair on the global
        let install = |name: &str,
                       ctor_obj: GcRef<JsObject>,
                       proto: GcRef<JsObject>,
                       ctor_fn: Option<
            Box<
                dyn Fn(&Value, &[Value], Arc<MemoryManager>) -> Result<Value, String>
                    + Send
                    + Sync,
            >,
        >| {
            // Wire constructor.prototype = prototype
            ctor_obj.define_property(
                PropertyKey::string("prototype"),
                PropertyDescriptor::data_with_attrs(
                    Value::object(proto),
                    PropertyAttributes {
                        writable: false,
                        enumerable: false,
                        configurable: false,
                    },
                ),
            );

            // Create constructor Value
            let ctor_value = if let Some(f) = ctor_fn {
                Value::native_function_with_proto_and_object(
                    Arc::from(f),
                    mm.clone(),
                    fn_proto,
                    ctor_obj,
                )
            } else {
                Value::object(ctor_obj)
            };

            // Wire prototype.constructor = ctor
            proto.define_property(
                PropertyKey::string("constructor"),
                PropertyDescriptor::data_with_attrs(
                    ctor_value.clone(),
                    PropertyAttributes::constructor_link(),
                ),
            );

            // Set name and length on constructor
            if let Some(obj) = ctor_value.as_object() {
                obj.define_property(
                    PropertyKey::string("name"),
                    PropertyDescriptor::function_length(Value::string(JsString::intern(name))),
                );
                obj.define_property(
                    PropertyKey::string("length"),
                    PropertyDescriptor::function_length(Value::number(1.0)),
                );
            }

            // Install on global as non-enumerable (spec behavior)
            global.define_property(
                PropertyKey::string(name),
                PropertyDescriptor::data_with_attrs(ctor_value, PropertyAttributes::builtin_method()),
            );
        };

        // ====================================================================
        // Core constructors
        // ====================================================================
        install("Object", self.object_constructor, self.object_prototype, None);
        install("Function", self.function_constructor, self.function_prototype, None);

        // Register global aliases for interpreter interception
        // The interpreter checks for these globals to detect and intercept
        // Function.prototype.call/apply (see interpreter.rs:5647, 5651)
        if let Some(call_fn) = self.function_prototype.get(&PropertyKey::string("call")) {
            global.set(PropertyKey::string("__Function_call"), call_fn);
        }
        if let Some(apply_fn) = self.function_prototype.get(&PropertyKey::string("apply")) {
            global.set(PropertyKey::string("__Function_apply"), apply_fn);
        }

        // ====================================================================
        // Primitive wrapper constructors
        // ====================================================================

        // For constructors that need actual implementations, we allocate fresh
        // constructor objects (since intrinsics only pre-allocated prototypes).
        // The prototype still comes from intrinsics with correct [[Prototype]] chain.
        let alloc_ctor = || GcRef::new(JsObject::new(Some(fn_proto), mm.clone()));

        // String
        let string_ctor = alloc_ctor();
        install("String", string_ctor, self.string_prototype, None);

        // String.fromCharCode(...codeUnits)
        string_ctor.define_property(
            PropertyKey::string("fromCharCode"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let mut result = String::new();
                    for arg in args {
                        let code = if let Some(n) = arg.as_number() {
                            (n as u32 & 0xFFFF) as u16
                        } else if let Some(i) = arg.as_int32() {
                            (i as u32 & 0xFFFF) as u16
                        } else {
                            0
                        };
                        if let Some(ch) = char::from_u32(code as u32) {
                            result.push(ch);
                        }
                    }
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // String.fromCodePoint(...codePoints)
        string_ctor.define_property(
            PropertyKey::string("fromCodePoint"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let mut result = String::new();
                    for arg in args {
                        let code = if let Some(n) = arg.as_number() {
                            n as u32
                        } else if let Some(i) = arg.as_int32() {
                            i as u32
                        } else {
                            0
                        };
                        if code > 0x10FFFF {
                            return Err(format!("Invalid code point: {}", code));
                        }
                        if let Some(ch) = char::from_u32(code) {
                            result.push(ch);
                        } else {
                            return Err(format!("Invalid code point: {}", code));
                        }
                    }
                    Ok(Value::string(JsString::intern(&result)))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number
        let number_ctor = alloc_ctor();
        install("Number", number_ctor, self.number_prototype, None);

        // Number constants
        number_ctor.define_property(
            PropertyKey::string("EPSILON"),
            PropertyDescriptor::data_with_attrs(
                Value::number(f64::EPSILON),
                PropertyAttributes::permanent(),
            ),
        );
        number_ctor.define_property(
            PropertyKey::string("MAX_VALUE"),
            PropertyDescriptor::data_with_attrs(
                Value::number(f64::MAX),
                PropertyAttributes::permanent(),
            ),
        );
        number_ctor.define_property(
            PropertyKey::string("MIN_VALUE"),
            PropertyDescriptor::data_with_attrs(
                Value::number(f64::MIN_POSITIVE),
                PropertyAttributes::permanent(),
            ),
        );
        number_ctor.define_property(
            PropertyKey::string("MAX_SAFE_INTEGER"),
            PropertyDescriptor::data_with_attrs(
                Value::number(9007199254740991.0), // 2^53 - 1
                PropertyAttributes::permanent(),
            ),
        );
        number_ctor.define_property(
            PropertyKey::string("MIN_SAFE_INTEGER"),
            PropertyDescriptor::data_with_attrs(
                Value::number(-9007199254740991.0), // -(2^53 - 1)
                PropertyAttributes::permanent(),
            ),
        );
        number_ctor.define_property(
            PropertyKey::string("POSITIVE_INFINITY"),
            PropertyDescriptor::data_with_attrs(
                Value::number(f64::INFINITY),
                PropertyAttributes::permanent(),
            ),
        );
        number_ctor.define_property(
            PropertyKey::string("NEGATIVE_INFINITY"),
            PropertyDescriptor::data_with_attrs(
                Value::number(f64::NEG_INFINITY),
                PropertyAttributes::permanent(),
            ),
        );
        number_ctor.define_property(
            PropertyKey::string("NaN"),
            PropertyDescriptor::data_with_attrs(
                Value::number(f64::NAN),
                PropertyAttributes::permanent(),
            ),
        );

        // Number.isFinite
        number_ctor.define_property(
            PropertyKey::string("isFinite"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let val = args.first();
                    match val {
                        Some(v) if v.is_number() => {
                            let n = v.as_number().unwrap();
                            Ok(Value::boolean(n.is_finite()))
                        }
                        Some(v) if v.is_int32() => Ok(Value::boolean(true)),
                        _ => Ok(Value::boolean(false)),
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.isInteger
        number_ctor.define_property(
            PropertyKey::string("isInteger"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let val = args.first();
                    match val {
                        Some(v) if v.is_int32() => Ok(Value::boolean(true)),
                        Some(v) if v.is_number() => {
                            let n = v.as_number().unwrap();
                            Ok(Value::boolean(n.is_finite() && n.fract() == 0.0))
                        }
                        _ => Ok(Value::boolean(false)),
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.isNaN
        number_ctor.define_property(
            PropertyKey::string("isNaN"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let val = args.first();
                    match val {
                        Some(v) if v.is_number() => {
                            let n = v.as_number().unwrap();
                            Ok(Value::boolean(n.is_nan()))
                        }
                        _ => Ok(Value::boolean(false)),
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.isSafeInteger
        number_ctor.define_property(
            PropertyKey::string("isSafeInteger"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let val = args.first();
                    match val {
                        Some(v) if v.is_int32() => Ok(Value::boolean(true)),
                        Some(v) if v.is_number() => {
                            let n = v.as_number().unwrap();
                            let max_safe = 9007199254740991.0; // 2^53 - 1
                            Ok(Value::boolean(
                                n.is_finite()
                                    && n.fract() == 0.0
                                    && n.abs() <= max_safe,
                            ))
                        }
                        _ => Ok(Value::boolean(false)),
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.parseFloat
        number_ctor.define_property(
            PropertyKey::string("parseFloat"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let val = args.first().ok_or("parseFloat requires an argument")?;
                    if let Some(s) = val.as_string() {
                        let trimmed = s.as_str().trim_start();
                        if let Ok(n) = trimmed.parse::<f64>() {
                            Ok(Value::number(n))
                        } else {
                            Ok(Value::number(f64::NAN))
                        }
                    } else {
                        Ok(Value::number(f64::NAN))
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Number.parseInt
        number_ctor.define_property(
            PropertyKey::string("parseInt"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let val = args.first().ok_or("parseInt requires an argument")?;
                    let radix = args.get(1).and_then(|v| v.as_int32()).unwrap_or(10);

                    if radix < 2 || radix > 36 {
                        return Ok(Value::number(f64::NAN));
                    }

                    if let Some(s) = val.as_string() {
                        let trimmed = s.as_str().trim_start();
                        if let Ok(n) = i64::from_str_radix(trimmed, radix as u32) {
                            Ok(Value::number(n as f64))
                        } else {
                            Ok(Value::number(f64::NAN))
                        }
                    } else {
                        Ok(Value::number(f64::NAN))
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Boolean
        let boolean_ctor = alloc_ctor();
        install("Boolean", boolean_ctor, self.boolean_prototype, None);

        // Symbol
        let symbol_ctor = alloc_ctor();
        install("Symbol", symbol_ctor, self.symbol_prototype, None);

        // BigInt
        let bigint_ctor = alloc_ctor();
        install("BigInt", bigint_ctor, self.bigint_prototype, None);

        // ====================================================================
        // Collection constructors
        // ====================================================================
        let array_ctor = alloc_ctor();
        install("Array", array_ctor, self.array_prototype, None);

        // Array.isArray
        array_ctor.define_property(
            PropertyKey::string("isArray"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    let is_arr = args
                        .first()
                        .and_then(|v| v.as_object())
                        .map(|o| o.is_array())
                        .unwrap_or(false);
                    Ok(Value::boolean(is_arr))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.from (simplified - handles array-like objects)
        array_ctor.define_property(
            PropertyKey::string("from"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, mm_inner| {
                    let source = args.first().ok_or_else(|| {
                        "Array.from requires an argument".to_string()
                    })?;
                    // Handle array-like objects (with length)
                    if let Some(obj) = source.as_object() {
                        if let Some(len_val) =
                            obj.get(&PropertyKey::string("length"))
                        {
                            let len = len_val.as_number().unwrap_or(0.0) as usize;
                            let result =
                                GcRef::new(JsObject::array(len, mm_inner));
                            for i in 0..len {
                                let val = obj
                                    .get(&PropertyKey::Index(i as u32))
                                    .unwrap_or(Value::undefined());
                                result.set(PropertyKey::Index(i as u32), val);
                            }
                            return Ok(Value::array(result));
                        }
                    }
                    // For non-array-like, return empty array
                    Ok(Value::array(GcRef::new(JsObject::array(0, mm_inner))))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Array.of
        array_ctor.define_property(
            PropertyKey::string("of"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, mm_inner| {
                    let result =
                        GcRef::new(JsObject::array(args.len(), mm_inner));
                    for (i, arg) in args.iter().enumerate() {
                        result.set(PropertyKey::Index(i as u32), arg.clone());
                    }
                    Ok(Value::array(result))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        let map_ctor = alloc_ctor();
        install("Map", map_ctor, self.map_prototype, None);

        let set_ctor = alloc_ctor();
        install("Set", set_ctor, self.set_prototype, None);

        let weak_map_ctor = alloc_ctor();
        install("WeakMap", weak_map_ctor, self.weak_map_prototype, None);

        let weak_set_ctor = alloc_ctor();
        install("WeakSet", weak_set_ctor, self.weak_set_prototype, None);

        // ====================================================================
        // Error constructors
        // ====================================================================
        let error_ctor = alloc_ctor();
        install("Error", error_ctor, self.error_prototype, None);

        let type_error_ctor = alloc_ctor();
        install("TypeError", type_error_ctor, self.type_error_prototype, None);

        let range_error_ctor = alloc_ctor();
        install("RangeError", range_error_ctor, self.range_error_prototype, None);

        let reference_error_ctor = alloc_ctor();
        install("ReferenceError", reference_error_ctor, self.reference_error_prototype, None);

        let syntax_error_ctor = alloc_ctor();
        install("SyntaxError", syntax_error_ctor, self.syntax_error_prototype, None);

        let uri_error_ctor = alloc_ctor();
        install("URIError", uri_error_ctor, self.uri_error_prototype, None);

        let eval_error_ctor = alloc_ctor();
        install("EvalError", eval_error_ctor, self.eval_error_prototype, None);

        // ====================================================================
        // Other builtins
        // ====================================================================
        let promise_ctor = alloc_ctor();
        install("Promise", promise_ctor, self.promise_prototype, None);

        let regexp_ctor = alloc_ctor();
        install("RegExp", regexp_ctor, self.regexp_prototype, None);

        let date_ctor = alloc_ctor();
        install("Date", date_ctor, self.date_prototype, None);

        // Date.now() - returns current timestamp in milliseconds
        date_ctor.define_property(
            PropertyKey::string("now"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, _args, _mm| {
                    use std::time::{SystemTime, UNIX_EPOCH};
                    let timestamp = SystemTime::now()
                        .duration_since(UNIX_EPOCH)
                        .map(|d| d.as_millis() as f64)
                        .unwrap_or(0.0);
                    Ok(Value::number(timestamp))
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.parse(dateString) - parses ISO 8601 date strings
        date_ctor.define_property(
            PropertyKey::string("parse"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    use chrono::{DateTime, NaiveDate, NaiveDateTime};

                    let date_str = args
                        .first()
                        .and_then(|v| v.as_string())
                        .ok_or("Date.parse requires a string argument")?;

                    let s = date_str.as_str();

                    // Try parsing as RFC3339/ISO8601 with timezone
                    let parsed = DateTime::parse_from_rfc3339(s)
                        .map(|dt| dt.timestamp_millis() as f64)
                        .or_else(|_| {
                            // Try parsing as naive datetime
                            NaiveDateTime::parse_from_str(s, "%Y-%m-%dT%H:%M:%S")
                                .or_else(|_| NaiveDateTime::parse_from_str(s, "%Y-%m-%dT%H:%M:%S%.f"))
                                .map(|dt| dt.and_utc().timestamp_millis() as f64)
                        })
                        .or_else(|_| {
                            // Try parsing as date only
                            NaiveDate::parse_from_str(s, "%Y-%m-%d")
                                .map(|d| d.and_hms_opt(0, 0, 0).unwrap().and_utc().timestamp_millis() as f64)
                        });

                    match parsed {
                        Ok(ts) => Ok(Value::number(ts)),
                        Err(_) => Ok(Value::number(f64::NAN)),
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        // Date.UTC(year, month, day, hour, min, sec, ms) - constructs UTC timestamp
        date_ctor.define_property(
            PropertyKey::string("UTC"),
            PropertyDescriptor::builtin_method(Value::native_function_with_proto(
                |_this, args, _mm| {
                    use chrono::NaiveDate;

                    if args.is_empty() {
                        return Ok(Value::number(f64::NAN));
                    }

                    let year = args.get(0).and_then(|v| v.as_int32()).unwrap_or(1970);
                    let month = args.get(1).and_then(|v| v.as_int32()).unwrap_or(0) + 1; // JS months are 0-indexed
                    let day = args.get(2).and_then(|v| v.as_int32()).unwrap_or(1);
                    let hour = args.get(3).and_then(|v| v.as_int32()).unwrap_or(0);
                    let minute = args.get(4).and_then(|v| v.as_int32()).unwrap_or(0);
                    let second = args.get(5).and_then(|v| v.as_int32()).unwrap_or(0);
                    let ms = args.get(6).and_then(|v| v.as_int32()).unwrap_or(0);

                    let date = NaiveDate::from_ymd_opt(year, month as u32, day as u32)
                        .and_then(|d| d.and_hms_milli_opt(hour as u32, minute as u32, second as u32, ms as u32));

                    match date {
                        Some(dt) => {
                            let timestamp = dt.and_utc().timestamp_millis() as f64;
                            Ok(Value::number(timestamp))
                        }
                        None => Ok(Value::number(f64::NAN)),
                    }
                },
                mm.clone(),
                fn_proto,
            )),
        );

        let array_buffer_ctor = alloc_ctor();
        install("ArrayBuffer", array_buffer_ctor, self.array_buffer_prototype, None);

        let data_view_ctor = alloc_ctor();
        install("DataView", data_view_ctor, self.data_view_prototype, None);

        // ====================================================================
        // Non-constructor namespace objects (Reflect, Math, JSON installed via builtins.js for now)
        // ====================================================================

        // Install well-known symbols on Symbol constructor
        if let Some(sym_ctor_obj) = global
            .get(&PropertyKey::string("Symbol"))
            .and_then(|v| v.as_object())
        {
            let sym_attrs = PropertyAttributes::permanent();
            let install_sym = |name: &str, sym_val: &Value| {
                sym_ctor_obj.define_property(
                    PropertyKey::string(name),
                    PropertyDescriptor::data_with_attrs(sym_val.clone(), sym_attrs),
                );
            };
            install_sym("iterator", &self.symbol_iterator);
            install_sym("asyncIterator", &self.symbol_async_iterator);
            install_sym("toStringTag", &self.symbol_to_string_tag);
            install_sym("hasInstance", &self.symbol_has_instance);
            install_sym("toPrimitive", &self.symbol_to_primitive);
            install_sym("isConcatSpreadable", &self.symbol_is_concat_spreadable);
            install_sym("match", &self.symbol_match);
            install_sym("matchAll", &self.symbol_match_all);
            install_sym("replace", &self.symbol_replace);
            install_sym("search", &self.symbol_search);
            install_sym("split", &self.symbol_split);
            install_sym("species", &self.symbol_species);
            install_sym("unscopables", &self.symbol_unscopables);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_intrinsics_allocate() {
        let mm = Arc::new(MemoryManager::test());
        let fn_proto = GcRef::new(JsObject::new(None, mm.clone()));
        let intrinsics = Intrinsics::allocate(&mm, fn_proto);

        // All well-known symbols should be symbols
        assert!(intrinsics.symbol_iterator.is_symbol());
        assert!(intrinsics.symbol_async_iterator.is_symbol());
        assert!(intrinsics.symbol_to_string_tag.is_symbol());
        assert!(intrinsics.symbol_has_instance.is_symbol());
        assert!(intrinsics.symbol_to_primitive.is_symbol());
        assert!(intrinsics.symbol_species.is_symbol());
    }

    #[test]
    fn test_prototype_chain_wiring() {
        let mm = Arc::new(MemoryManager::test());
        let fn_proto = GcRef::new(JsObject::new(None, mm.clone()));
        let intrinsics = Intrinsics::allocate(&mm, fn_proto);
        intrinsics.wire_prototype_chains();

        // Object.prototype.__proto__ === null
        assert!(intrinsics.object_prototype.prototype().is_none());

        // Function.prototype.__proto__ === Object.prototype
        let fp_proto = intrinsics.function_prototype.prototype();
        assert!(fp_proto.is_some());

        // Array.prototype.__proto__ === Object.prototype
        let ap_proto = intrinsics.array_prototype.prototype();
        assert!(ap_proto.is_some());

        // TypeError.prototype.__proto__ === Error.prototype
        let tep_proto = intrinsics.type_error_prototype.prototype();
        assert!(tep_proto.is_some());
    }
}
