use anyhow::{Context, Result};
use clap::Args;
use otter_jsc_sys::bytecode;
use otter_runtime::{JscConfig, JscRuntime};
use std::fs;
use std::path::PathBuf;

#[derive(Args, Debug)]
pub struct CompileCommand {
    /// Input JavaScript file
    #[arg(required = true)]
    input: PathBuf,

    /// Output bytecode file (.jsc)
    #[arg(required = true)]
    output: PathBuf,

    /// Treat input as ES Module
    #[arg(long)]
    module: bool,
}

impl CompileCommand {
    pub async fn run(self) -> Result<()> {
        println!(
            "Compiling {} -> {}...",
            self.input.display(),
            self.output.display()
        );

        // Read source file
        let source = fs::read_to_string(&self.input)
            .with_context(|| format!("Failed to read input file: {}", self.input.display()))?;

        // Initialize a minimal runtime to get a valid JSContext
        // We don't need extensions or event loop, just the context
        let runtime = JscRuntime::new(JscConfig::default())?;
        let ctx = runtime.context().raw();

        // Convert paths to strings
        let filename = self.input.to_string_lossy();
        let output_path = self.output.to_string_lossy();

        let size = if self.module {
            bytecode::generate_module_bytecode_to_file(ctx, &source, &filename, &output_path)
        } else {
            bytecode::generate_program_bytecode_to_file(ctx, &source, &filename, &output_path)
        }
        .map_err(|e| anyhow::anyhow!("Compilation failed: {}", e))?;

        println!("Success! Generated bytecode size: {} bytes", size);

        Ok(())
    }
}
