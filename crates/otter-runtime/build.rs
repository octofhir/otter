//! Build script for otter-runtime
//!
//! This embeds TypeScript type definitions at compile time so they can be
//! accessed at runtime without requiring separate files.

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    embed_type_definitions();
}

/// Embed all .d.ts files from the types/ directory into the binary.
fn embed_type_definitions() {
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("embedded_types.rs");

    let types_dir = Path::new("types");
    let mut entries = Vec::new();

    if types_dir.exists() {
        collect_type_files(types_dir, types_dir, &mut entries);
    }

    // Generate Rust code that embeds the type definitions
    let mut code = String::from(
        "// Auto-generated embedded type definitions\n\
         // Do not edit this file directly.\n\n\
         /// Embedded TypeScript type definition files.\n\
         /// Each entry is (relative_path, contents).\n\
         pub static EMBEDDED_TYPES: &[(&str, &str)] = &[\n",
    );

    for (path, contents) in entries {
        // Escape the contents for use in a Rust string literal
        let escaped = contents
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t");

        code.push_str(&format!("    (\"{}\", \"{}\"),\n", path, escaped));
    }

    code.push_str("];\n\n");

    // Add helper functions
    code.push_str(
        "/// Get the contents of an embedded type definition file.\n\
         pub fn get_embedded_type(name: &str) -> Option<&'static str> {\n\
         \x20   EMBEDDED_TYPES.iter()\n\
         \x20       .find(|(path, _)| *path == name || path.ends_with(name))\n\
         \x20       .map(|(_, contents)| *contents)\n\
         }\n\n\
         /// Get all embedded type definition file names.\n\
         pub fn list_embedded_types() -> impl Iterator<Item = &'static str> {\n\
         \x20   EMBEDDED_TYPES.iter().map(|(path, _)| *path)\n\
         }\n",
    );

    fs::write(&dest_path, code).expect("Failed to write embedded_types.rs");

    // Tell Cargo to rerun if any type definition files change
    println!("cargo:rerun-if-changed=types/");
}

/// Recursively collect all .d.ts files from a directory.
fn collect_type_files(base: &Path, dir: &Path, entries: &mut Vec<(String, String)>) {
    let Ok(read_dir) = fs::read_dir(dir) else {
        return;
    };

    for entry in read_dir.flatten() {
        let path = entry.path();

        if path.is_dir() {
            collect_type_files(base, &path, entries);
        } else if is_type_definition(&path)
            && let Ok(contents) = fs::read_to_string(&path)
        {
            let relative = path
                .strip_prefix(base)
                .unwrap_or(&path)
                .to_string_lossy()
                .to_string();

            entries.push((relative, contents));
        }
    }
}

/// Check if a file is a TypeScript type definition.
fn is_type_definition(path: &Path) -> bool {
    path.extension()
        .is_some_and(|ext| ext == "ts" || ext == "d.ts")
}
